/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Color } from "./utils/color";
import { OverlayData } from "./components/je-overlay/je-overlay";
import { OverlayData as OverlayData1 } from "./components/je-overlay/je-overlay";
import { Placement } from "@floating-ui/dom";
import { EditorChangeEvent } from "./components/je-rich-text/je-rich-text";
import { InputMaskOptions } from "./utils/input-mask";
export { Color } from "./utils/color";
export { OverlayData } from "./components/je-overlay/je-overlay";
export { OverlayData as OverlayData1 } from "./components/je-overlay/je-overlay";
export { Placement } from "@floating-ui/dom";
export { EditorChangeEvent } from "./components/je-rich-text/je-rich-text";
export { InputMaskOptions } from "./utils/input-mask";
export namespace Components {
    /**
     * Accordions are wrappers for <je-link href="../je-details">JeDetails</je-link>. When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface JeAccordion {
    }
    interface JeAlert {
        /**
          * @default false
         */
        "closable": boolean;
        "color"?: Color;
        "didDismiss": () => Promise<unknown>;
        /**
          * @default 0
         */
        "duration": number;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * @default false
         */
        "open": boolean;
        "show": () => Promise<void>;
    }
    interface JeBranch {
        "href"?: string;
        /**
          * @default false
         */
        "indentation": boolean;
        "isLeaf": () => Promise<boolean>;
        "label"?: string;
        /**
          * @default false
         */
        "open": boolean;
        /**
          * @default false
         */
        "selected": boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        /**
          * @default 1
         */
        "itemsAfterCollapse": number;
        /**
          * @default 1
         */
        "itemsBeforeCollapse": number;
        "maxItems"?: number;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
          * @default false
         */
        "disabled": boolean;
        /**
          * Expands the button to the full width of it's container
          * @default false
         */
        "expand": boolean;
        /**
          * Button fill
          * @default 'solid'
         */
        "fill": 'solid' | 'outline' | 'clear';
        /**
          * Can set form id to participate in forms. Use this if you need to place submit/reset button outside the form element
         */
        "form"?: string;
        /**
          * Shows a loading spinner and disables the button
          * @default false
         */
        "pending": boolean;
        /**
          * Button size
          * @default 'md'
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCalendar {
    }
    interface JeCard {
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * If the checkbox should contain a 3rd indeterminate state
          * @default false
         */
        "indeterminate": boolean;
        /**
          * Whether or not the label should go before or after the checkbox
          * @default 'end'
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
          * @default false
         */
        "required": boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color;
        /**
          * Color in dark mode
         */
        "dark"?: Color;
        /**
          * Color in light mode
         */
        "light"?: Color;
    }
    interface JeComp {
    }
    interface JeControl {
    }
    interface JeDatepicker {
        /**
          * @default false
         */
        "includeSeconds": boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        /**
          * @default "datetime"
         */
        "type": "date" | "datetime" | "time";
        "value"?: number;
    }
    interface JeDaw {
    }
    interface JeDetails {
        /**
          * @default "right"
         */
        "iconSide": "left" | "right";
        /**
          * @default false
         */
        "iconToggle": boolean;
        /**
          * @default false
         */
        "open": boolean;
        "summary"?: string;
    }
    interface JeDiscardForm {
    }
    interface JeDivider {
        /**
          * @default 'md'
         */
        "spacing": 'sm' | 'md' | 'lg' | 'none';
        /**
          * @default 'horizontal'
         */
        "type": 'horizontal' | 'vertical';
    }
    interface JeDropzone {
    }
    interface JeEq {
    }
    interface JeForm {
        "addInvalidSubmission": (element: HTMLElement) => Promise<boolean>;
    }
    interface JeGrid {
        "space"?: | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
          * @default false
         */
        "fill": boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
          * @default 'md'
         */
        "size": 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
          * @default 400
         */
        "weight": number;
    }
    interface JeItem {
    }
    interface JeKnob {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
          * @default false
         */
        "bold": boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
          * @default true
         */
        "underline": boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeMidi {
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "value": any;
    }
    interface JeOverlay {
        /**
          * Backdrop will close the modal on click when enabled
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * Optionally execute a promise after closing completes
         */
        "destroy"?: () => void | Promise<void>;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Opens and closes modal
          * @default false
         */
        "open": boolean;
        "show": () => Promise<void>;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side"?: "left" | "right" | "bottom" | "top";
        /**
          * Size of the overlay
          * @default "md"
         */
        "size": "sm" | "md" | "lg";
    }
    interface JePill {
        /**
          * @default false
         */
        "outline": boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
          * @default true
         */
        "animated": boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
          * @default true
         */
        "arrow": boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
          * @default 6
         */
        "arrowPadding": number;
        /**
          * Backdrop will dismiss the popover on click when enabled
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
          * @default false
         */
        "dismissOnClick": boolean;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
          * @default false
         */
        "matchWidth": boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY": number;
        /**
          * Opens/closes the popover
          * @default false
         */
        "open": boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
          * @default "element"
         */
        "positionStrategy": "click" | "element";
        "show": () => Promise<void>;
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
          * @default "click"
         */
        "triggerAction": "click" | "context-menu" | "hover";
    }
    interface JeRadio {
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value": any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
          * @default false
         */
        "selected": boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Disables the controls
          * @default false
         */
        "disabled": boolean;
        /**
          * Label that shows above the control
         */
        "label"?: string;
        /**
          * Additional info that shows below the control
         */
        "note"?: string;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRange {
    }
    interface JeReorderItem {
    }
    interface JeReorderList {
    }
    interface JeRichText {
        "clear": () => Promise<void>;
        /**
          * @default false
         */
        "disabled": boolean;
        "getContent": () => Promise<string>;
        "getText": () => Promise<string>;
        /**
          * @default '500px'
         */
        "maxHeight": string;
        /**
          * @default '200px'
         */
        "minHeight": string;
        /**
          * @default 'Start typing...'
         */
        "placeholder": string;
        /**
          * @default false
         */
        "readonly": boolean;
        "setContent": (html: string) => Promise<void>;
        /**
          * @default true
         */
        "showWordCount": boolean;
        /**
          * @default ''
         */
        "value": string;
    }
    interface JeSelect {
        /**
          * @default false
         */
        "disabled": boolean;
        "label"?: string;
        /**
          * @default false
         */
        "multiple": boolean;
        "note"?: string;
        "options"?: { value: any; label: string }[];
        "originalValue": any;
        "placeholder"?: string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default "md"
         */
        "size": "md" | "lg" | "sm";
        "value": any;
    }
    interface JeSplitPanel {
    }
    interface JeSplitView {
    }
    interface JeStack {
        "align"?: string;
        "justify"?: string;
        /**
          * @default "column"
         */
        "mode": "row" | "column";
        /**
          * @default "md"
         */
        "space": | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeSynth {
    }
    interface JeTab {
        /**
          * @default false
         */
        "active": boolean;
        "value"?: string;
    }
    interface JeTable {
        "columns"?: number;
    }
    interface JeTabs {
        /**
          * @default 'segment'
         */
        "mode": 'mobile' | 'pill' | 'segment';
        "value"?: string;
    }
    interface JeTc {
        "colSpan"?: number;
        /**
          * @default false
         */
        "copy": boolean;
        "rowSpan"?: number;
    }
    interface JeTextfield {
        /**
          * Optional debounce of the didInput event
          * @default 0
         */
        "debounce": number;
        /**
          * Renders input as disabled and prevents changes
          * @default false
         */
        "disabled": boolean;
        "isTouched": () => Promise<boolean>;
        /**
          * Text above the control
         */
        "label"?: string;
        "markAsTouched": () => Promise<void>;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
          * @default false
         */
        "multiline": boolean;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: any;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
          * @default false
         */
        "readonly": boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
          * @default false
         */
        "required": boolean;
        /**
          * Container size
          * @default 'md'
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * @default 'text'
         */
        "type": 'text'
    | 'number'
    | 'search'
    | 'email'
    | 'phone'
    | 'url'
    | 'money'
    | 'date'
    | 'time'
    | 'datetime'
    | 'daterange'
    | 'password'
    | 'ssn'
    | Omit<InputMaskOptions, 'inputElement'>;
        /**
          * Current value of the input
         */
        "value": any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToc {
    }
    interface JeToggle {
        /**
          * If the label should be placed at the start or end of the toggle
          * @default 'end'
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Original value form will reset to
         */
        "originalValue": boolean;
        /**
          * Whether or not the toggle is active
          * @default false
         */
        "value": boolean;
    }
    interface JeToolbar {
        /**
          * @default false
         */
        "flank": boolean | "reverse";
        /**
          * @default "row"
         */
        "mode": "row" | "column";
        /**
          * @default "md"
         */
        "space": | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY": number;
    }
    interface JeTr {
        /**
          * @default "body"
         */
        "type": "header" | "body" | "footer";
    }
    interface JeTree {
        /**
          * @default false
         */
        "indentation": boolean;
        /**
          * @default 'leaf'
         */
        "selection": 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeView {
        /**
          * @default true
         */
        "closable": boolean;
        "label"?: string;
    }
    interface JeViewManager {
    }
    interface JeWizard {
        "canSkip": () => Promise<boolean>;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        "reset": () => Promise<void>;
        "skip": () => Promise<void>;
        /**
          * @default []
         */
        "steps": { label: string, optional?: boolean }[];
    }
}
export interface JeAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeAlertElement;
}
export interface JeBreadcrumbsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeBreadcrumbsElement;
}
export interface JeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxElement;
}
export interface JeDatepickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDatepickerElement;
}
export interface JeDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDetailsElement;
}
export interface JeDropzoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDropzoneElement;
}
export interface JeFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeFormElement;
}
export interface JeOverlayCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeOverlayElement;
}
export interface JePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJePopoverElement;
}
export interface JeRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRadioGroupElement;
}
export interface JeRichTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRichTextElement;
}
export interface JeSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeSelectElement;
}
export interface JeTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTabsElement;
}
export interface JeTextfieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTextfieldElement;
}
export interface JeToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeToggleElement;
}
export interface JeTreeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTreeElement;
}
export interface JeWizardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeWizardElement;
}
declare global {
    /**
     * Accordions are wrappers for <je-link href="../je-details">JeDetails</je-link>. When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface HTMLJeAccordionElement extends Components.JeAccordion, HTMLStencilElement {
    }
    var HTMLJeAccordionElement: {
        prototype: HTMLJeAccordionElement;
        new (): HTMLJeAccordionElement;
    };
    interface HTMLJeAlertElementEventMap {
        "present": any;
        "dismiss": OverlayData;
    }
    interface HTMLJeAlertElement extends Components.JeAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeAlertElement: {
        prototype: HTMLJeAlertElement;
        new (): HTMLJeAlertElement;
    };
    interface HTMLJeBranchElement extends Components.JeBranch, HTMLStencilElement {
    }
    var HTMLJeBranchElement: {
        prototype: HTMLJeBranchElement;
        new (): HTMLJeBranchElement;
    };
    interface HTMLJeBreadcrumbElement extends Components.JeBreadcrumb, HTMLStencilElement {
    }
    var HTMLJeBreadcrumbElement: {
        prototype: HTMLJeBreadcrumbElement;
        new (): HTMLJeBreadcrumbElement;
    };
    interface HTMLJeBreadcrumbsElementEventMap {
        "expandClick": any;
    }
    interface HTMLJeBreadcrumbsElement extends Components.JeBreadcrumbs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeBreadcrumbsElement: {
        prototype: HTMLJeBreadcrumbsElement;
        new (): HTMLJeBreadcrumbsElement;
    };
    interface HTMLJeButtonElement extends Components.JeButton, HTMLStencilElement {
    }
    var HTMLJeButtonElement: {
        prototype: HTMLJeButtonElement;
        new (): HTMLJeButtonElement;
    };
    interface HTMLJeButtonGroupElement extends Components.JeButtonGroup, HTMLStencilElement {
    }
    var HTMLJeButtonGroupElement: {
        prototype: HTMLJeButtonGroupElement;
        new (): HTMLJeButtonGroupElement;
    };
    interface HTMLJeCalendarElement extends Components.JeCalendar, HTMLStencilElement {
    }
    var HTMLJeCalendarElement: {
        prototype: HTMLJeCalendarElement;
        new (): HTMLJeCalendarElement;
    };
    interface HTMLJeCardElement extends Components.JeCard, HTMLStencilElement {
    }
    var HTMLJeCardElement: {
        prototype: HTMLJeCardElement;
        new (): HTMLJeCardElement;
    };
    interface HTMLJeCheckboxElementEventMap {
        "valueChange": boolean | undefined;
    }
    interface HTMLJeCheckboxElement extends Components.JeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxElement: {
        prototype: HTMLJeCheckboxElement;
        new (): HTMLJeCheckboxElement;
    };
    interface HTMLJeColorElement extends Components.JeColor, HTMLStencilElement {
    }
    var HTMLJeColorElement: {
        prototype: HTMLJeColorElement;
        new (): HTMLJeColorElement;
    };
    interface HTMLJeCompElement extends Components.JeComp, HTMLStencilElement {
    }
    var HTMLJeCompElement: {
        prototype: HTMLJeCompElement;
        new (): HTMLJeCompElement;
    };
    interface HTMLJeControlElement extends Components.JeControl, HTMLStencilElement {
    }
    var HTMLJeControlElement: {
        prototype: HTMLJeControlElement;
        new (): HTMLJeControlElement;
    };
    interface HTMLJeDatepickerElementEventMap {
        "valueChange": number;
    }
    interface HTMLJeDatepickerElement extends Components.JeDatepicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDatepickerElement: {
        prototype: HTMLJeDatepickerElement;
        new (): HTMLJeDatepickerElement;
    };
    interface HTMLJeDawElement extends Components.JeDaw, HTMLStencilElement {
    }
    var HTMLJeDawElement: {
        prototype: HTMLJeDawElement;
        new (): HTMLJeDawElement;
    };
    interface HTMLJeDetailsElementEventMap {
        "expand": any;
        "collapse": any;
    }
    interface HTMLJeDetailsElement extends Components.JeDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDetailsElement: {
        prototype: HTMLJeDetailsElement;
        new (): HTMLJeDetailsElement;
    };
    interface HTMLJeDiscardFormElement extends Components.JeDiscardForm, HTMLStencilElement {
    }
    var HTMLJeDiscardFormElement: {
        prototype: HTMLJeDiscardFormElement;
        new (): HTMLJeDiscardFormElement;
    };
    interface HTMLJeDividerElement extends Components.JeDivider, HTMLStencilElement {
    }
    var HTMLJeDividerElement: {
        prototype: HTMLJeDividerElement;
        new (): HTMLJeDividerElement;
    };
    interface HTMLJeDropzoneElementEventMap {
        "dataDrop": DataTransfer;
    }
    interface HTMLJeDropzoneElement extends Components.JeDropzone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDropzoneElement: {
        prototype: HTMLJeDropzoneElement;
        new (): HTMLJeDropzoneElement;
    };
    interface HTMLJeEqElement extends Components.JeEq, HTMLStencilElement {
    }
    var HTMLJeEqElement: {
        prototype: HTMLJeEqElement;
        new (): HTMLJeEqElement;
    };
    interface HTMLJeFormElementEventMap {
        "dataSubmit": Record<string, any>;
    }
    interface HTMLJeFormElement extends Components.JeForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeFormElement: {
        prototype: HTMLJeFormElement;
        new (): HTMLJeFormElement;
    };
    interface HTMLJeGridElement extends Components.JeGrid, HTMLStencilElement {
    }
    var HTMLJeGridElement: {
        prototype: HTMLJeGridElement;
        new (): HTMLJeGridElement;
    };
    interface HTMLJeIconElement extends Components.JeIcon, HTMLStencilElement {
    }
    var HTMLJeIconElement: {
        prototype: HTMLJeIconElement;
        new (): HTMLJeIconElement;
    };
    interface HTMLJeItemElement extends Components.JeItem, HTMLStencilElement {
    }
    var HTMLJeItemElement: {
        prototype: HTMLJeItemElement;
        new (): HTMLJeItemElement;
    };
    interface HTMLJeKnobElement extends Components.JeKnob, HTMLStencilElement {
    }
    var HTMLJeKnobElement: {
        prototype: HTMLJeKnobElement;
        new (): HTMLJeKnobElement;
    };
    interface HTMLJeLabelElement extends Components.JeLabel, HTMLStencilElement {
    }
    var HTMLJeLabelElement: {
        prototype: HTMLJeLabelElement;
        new (): HTMLJeLabelElement;
    };
    interface HTMLJeLinkElement extends Components.JeLink, HTMLStencilElement {
    }
    var HTMLJeLinkElement: {
        prototype: HTMLJeLinkElement;
        new (): HTMLJeLinkElement;
    };
    interface HTMLJeListElement extends Components.JeList, HTMLStencilElement {
    }
    var HTMLJeListElement: {
        prototype: HTMLJeListElement;
        new (): HTMLJeListElement;
    };
    interface HTMLJeLoadingElement extends Components.JeLoading, HTMLStencilElement {
    }
    var HTMLJeLoadingElement: {
        prototype: HTMLJeLoadingElement;
        new (): HTMLJeLoadingElement;
    };
    interface HTMLJeMidiElement extends Components.JeMidi, HTMLStencilElement {
    }
    var HTMLJeMidiElement: {
        prototype: HTMLJeMidiElement;
        new (): HTMLJeMidiElement;
    };
    interface HTMLJeNoteElement extends Components.JeNote, HTMLStencilElement {
    }
    var HTMLJeNoteElement: {
        prototype: HTMLJeNoteElement;
        new (): HTMLJeNoteElement;
    };
    interface HTMLJeOptionElement extends Components.JeOption, HTMLStencilElement {
    }
    var HTMLJeOptionElement: {
        prototype: HTMLJeOptionElement;
        new (): HTMLJeOptionElement;
    };
    interface HTMLJeOverlayElementEventMap {
        "present": any;
        "dismiss": OverlayData1;
    }
    interface HTMLJeOverlayElement extends Components.JeOverlay, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeOverlayElementEventMap>(type: K, listener: (this: HTMLJeOverlayElement, ev: JeOverlayCustomEvent<HTMLJeOverlayElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeOverlayElementEventMap>(type: K, listener: (this: HTMLJeOverlayElement, ev: JeOverlayCustomEvent<HTMLJeOverlayElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeOverlayElement: {
        prototype: HTMLJeOverlayElement;
        new (): HTMLJeOverlayElement;
    };
    interface HTMLJePillElement extends Components.JePill, HTMLStencilElement {
    }
    var HTMLJePillElement: {
        prototype: HTMLJePillElement;
        new (): HTMLJePillElement;
    };
    interface HTMLJePlaceholderElement extends Components.JePlaceholder, HTMLStencilElement {
    }
    var HTMLJePlaceholderElement: {
        prototype: HTMLJePlaceholderElement;
        new (): HTMLJePlaceholderElement;
    };
    interface HTMLJePopoverElementEventMap {
        "presentStart": any;
        "presentEnd": any;
        "dismissStart": any;
        "dismissEnd": any;
        "ready": any;
    }
    interface HTMLJePopoverElement extends Components.JePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJePopoverElement: {
        prototype: HTMLJePopoverElement;
        new (): HTMLJePopoverElement;
    };
    interface HTMLJeRadioElement extends Components.JeRadio, HTMLStencilElement {
    }
    var HTMLJeRadioElement: {
        prototype: HTMLJeRadioElement;
        new (): HTMLJeRadioElement;
    };
    interface HTMLJeRadioButtonElement extends Components.JeRadioButton, HTMLStencilElement {
    }
    var HTMLJeRadioButtonElement: {
        prototype: HTMLJeRadioButtonElement;
        new (): HTMLJeRadioButtonElement;
    };
    interface HTMLJeRadioGroupElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeRadioGroupElement extends Components.JeRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRadioGroupElement: {
        prototype: HTMLJeRadioGroupElement;
        new (): HTMLJeRadioGroupElement;
    };
    interface HTMLJeRangeElement extends Components.JeRange, HTMLStencilElement {
    }
    var HTMLJeRangeElement: {
        prototype: HTMLJeRangeElement;
        new (): HTMLJeRangeElement;
    };
    interface HTMLJeReorderItemElement extends Components.JeReorderItem, HTMLStencilElement {
    }
    var HTMLJeReorderItemElement: {
        prototype: HTMLJeReorderItemElement;
        new (): HTMLJeReorderItemElement;
    };
    interface HTMLJeReorderListElement extends Components.JeReorderList, HTMLStencilElement {
    }
    var HTMLJeReorderListElement: {
        prototype: HTMLJeReorderListElement;
        new (): HTMLJeReorderListElement;
    };
    interface HTMLJeRichTextElementEventMap {
        "editorChange": EditorChangeEvent;
        "editorFocus": FocusEvent;
        "editorBlur": FocusEvent;
    }
    interface HTMLJeRichTextElement extends Components.JeRichText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRichTextElementEventMap>(type: K, listener: (this: HTMLJeRichTextElement, ev: JeRichTextCustomEvent<HTMLJeRichTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRichTextElementEventMap>(type: K, listener: (this: HTMLJeRichTextElement, ev: JeRichTextCustomEvent<HTMLJeRichTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRichTextElement: {
        prototype: HTMLJeRichTextElement;
        new (): HTMLJeRichTextElement;
    };
    interface HTMLJeSelectElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeSelectElement extends Components.JeSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeSelectElementEventMap>(type: K, listener: (this: HTMLJeSelectElement, ev: JeSelectCustomEvent<HTMLJeSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeSelectElementEventMap>(type: K, listener: (this: HTMLJeSelectElement, ev: JeSelectCustomEvent<HTMLJeSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeSelectElement: {
        prototype: HTMLJeSelectElement;
        new (): HTMLJeSelectElement;
    };
    interface HTMLJeSplitPanelElement extends Components.JeSplitPanel, HTMLStencilElement {
    }
    var HTMLJeSplitPanelElement: {
        prototype: HTMLJeSplitPanelElement;
        new (): HTMLJeSplitPanelElement;
    };
    interface HTMLJeSplitViewElement extends Components.JeSplitView, HTMLStencilElement {
    }
    var HTMLJeSplitViewElement: {
        prototype: HTMLJeSplitViewElement;
        new (): HTMLJeSplitViewElement;
    };
    interface HTMLJeStackElement extends Components.JeStack, HTMLStencilElement {
    }
    var HTMLJeStackElement: {
        prototype: HTMLJeStackElement;
        new (): HTMLJeStackElement;
    };
    interface HTMLJeSynthElement extends Components.JeSynth, HTMLStencilElement {
    }
    var HTMLJeSynthElement: {
        prototype: HTMLJeSynthElement;
        new (): HTMLJeSynthElement;
    };
    interface HTMLJeTabElement extends Components.JeTab, HTMLStencilElement {
    }
    var HTMLJeTabElement: {
        prototype: HTMLJeTabElement;
        new (): HTMLJeTabElement;
    };
    interface HTMLJeTableElement extends Components.JeTable, HTMLStencilElement {
    }
    var HTMLJeTableElement: {
        prototype: HTMLJeTableElement;
        new (): HTMLJeTableElement;
    };
    interface HTMLJeTabsElementEventMap {
        "valueChange": string | undefined;
    }
    interface HTMLJeTabsElement extends Components.JeTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTabsElement: {
        prototype: HTMLJeTabsElement;
        new (): HTMLJeTabsElement;
    };
    interface HTMLJeTcElement extends Components.JeTc, HTMLStencilElement {
    }
    var HTMLJeTcElement: {
        prototype: HTMLJeTcElement;
        new (): HTMLJeTcElement;
    };
    interface HTMLJeTextfieldElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeTextfieldElement extends Components.JeTextfield, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTextfieldElement: {
        prototype: HTMLJeTextfieldElement;
        new (): HTMLJeTextfieldElement;
    };
    interface HTMLJeTocElement extends Components.JeToc, HTMLStencilElement {
    }
    var HTMLJeTocElement: {
        prototype: HTMLJeTocElement;
        new (): HTMLJeTocElement;
    };
    interface HTMLJeToggleElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLJeToggleElement extends Components.JeToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeToggleElement: {
        prototype: HTMLJeToggleElement;
        new (): HTMLJeToggleElement;
    };
    interface HTMLJeToolbarElement extends Components.JeToolbar, HTMLStencilElement {
    }
    var HTMLJeToolbarElement: {
        prototype: HTMLJeToolbarElement;
        new (): HTMLJeToolbarElement;
    };
    interface HTMLJeTooltipElement extends Components.JeTooltip, HTMLStencilElement {
    }
    var HTMLJeTooltipElement: {
        prototype: HTMLJeTooltipElement;
        new (): HTMLJeTooltipElement;
    };
    interface HTMLJeTrElement extends Components.JeTr, HTMLStencilElement {
    }
    var HTMLJeTrElement: {
        prototype: HTMLJeTrElement;
        new (): HTMLJeTrElement;
    };
    interface HTMLJeTreeElementEventMap {
        "valueChange": string | string[];
    }
    interface HTMLJeTreeElement extends Components.JeTree, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTreeElement: {
        prototype: HTMLJeTreeElement;
        new (): HTMLJeTreeElement;
    };
    interface HTMLJeViewElement extends Components.JeView, HTMLStencilElement {
    }
    var HTMLJeViewElement: {
        prototype: HTMLJeViewElement;
        new (): HTMLJeViewElement;
    };
    interface HTMLJeViewManagerElement extends Components.JeViewManager, HTMLStencilElement {
    }
    var HTMLJeViewManagerElement: {
        prototype: HTMLJeViewManagerElement;
        new (): HTMLJeViewManagerElement;
    };
    interface HTMLJeWizardElementEventMap {
        "stepChange": number;
        "finish": void;
    }
    interface HTMLJeWizardElement extends Components.JeWizard, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeWizardElement: {
        prototype: HTMLJeWizardElement;
        new (): HTMLJeWizardElement;
    };
    interface HTMLElementTagNameMap {
        "je-accordion": HTMLJeAccordionElement;
        "je-alert": HTMLJeAlertElement;
        "je-branch": HTMLJeBranchElement;
        "je-breadcrumb": HTMLJeBreadcrumbElement;
        "je-breadcrumbs": HTMLJeBreadcrumbsElement;
        "je-button": HTMLJeButtonElement;
        "je-button-group": HTMLJeButtonGroupElement;
        "je-calendar": HTMLJeCalendarElement;
        "je-card": HTMLJeCardElement;
        "je-checkbox": HTMLJeCheckboxElement;
        "je-color": HTMLJeColorElement;
        "je-comp": HTMLJeCompElement;
        "je-control": HTMLJeControlElement;
        "je-datepicker": HTMLJeDatepickerElement;
        "je-daw": HTMLJeDawElement;
        "je-details": HTMLJeDetailsElement;
        "je-discard-form": HTMLJeDiscardFormElement;
        "je-divider": HTMLJeDividerElement;
        "je-dropzone": HTMLJeDropzoneElement;
        "je-eq": HTMLJeEqElement;
        "je-form": HTMLJeFormElement;
        "je-grid": HTMLJeGridElement;
        "je-icon": HTMLJeIconElement;
        "je-item": HTMLJeItemElement;
        "je-knob": HTMLJeKnobElement;
        "je-label": HTMLJeLabelElement;
        "je-link": HTMLJeLinkElement;
        "je-list": HTMLJeListElement;
        "je-loading": HTMLJeLoadingElement;
        "je-midi": HTMLJeMidiElement;
        "je-note": HTMLJeNoteElement;
        "je-option": HTMLJeOptionElement;
        "je-overlay": HTMLJeOverlayElement;
        "je-pill": HTMLJePillElement;
        "je-placeholder": HTMLJePlaceholderElement;
        "je-popover": HTMLJePopoverElement;
        "je-radio": HTMLJeRadioElement;
        "je-radio-button": HTMLJeRadioButtonElement;
        "je-radio-group": HTMLJeRadioGroupElement;
        "je-range": HTMLJeRangeElement;
        "je-reorder-item": HTMLJeReorderItemElement;
        "je-reorder-list": HTMLJeReorderListElement;
        "je-rich-text": HTMLJeRichTextElement;
        "je-select": HTMLJeSelectElement;
        "je-split-panel": HTMLJeSplitPanelElement;
        "je-split-view": HTMLJeSplitViewElement;
        "je-stack": HTMLJeStackElement;
        "je-synth": HTMLJeSynthElement;
        "je-tab": HTMLJeTabElement;
        "je-table": HTMLJeTableElement;
        "je-tabs": HTMLJeTabsElement;
        "je-tc": HTMLJeTcElement;
        "je-textfield": HTMLJeTextfieldElement;
        "je-toc": HTMLJeTocElement;
        "je-toggle": HTMLJeToggleElement;
        "je-toolbar": HTMLJeToolbarElement;
        "je-tooltip": HTMLJeTooltipElement;
        "je-tr": HTMLJeTrElement;
        "je-tree": HTMLJeTreeElement;
        "je-view": HTMLJeViewElement;
        "je-view-manager": HTMLJeViewManagerElement;
        "je-wizard": HTMLJeWizardElement;
    }
}
declare namespace LocalJSX {
    /**
     * Accordions are wrappers for <je-link href="../je-details">JeDetails</je-link>. When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface JeAccordion {
    }
    interface JeAlert {
        /**
          * @default false
         */
        "closable"?: boolean;
        "color"?: Color;
        /**
          * @default 0
         */
        "duration"?: number;
        "onDismiss"?: (event: JeAlertCustomEvent<OverlayData>) => void;
        "onPresent"?: (event: JeAlertCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
    }
    interface JeBranch {
        "href"?: string;
        /**
          * @default false
         */
        "indentation"?: boolean;
        "label"?: string;
        /**
          * @default false
         */
        "open"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        /**
          * @default 1
         */
        "itemsAfterCollapse"?: number;
        /**
          * @default 1
         */
        "itemsBeforeCollapse"?: number;
        "maxItems"?: number;
        "onExpandClick"?: (event: JeBreadcrumbsCustomEvent<any>) => void;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Expands the button to the full width of it's container
          * @default false
         */
        "expand"?: boolean;
        /**
          * Button fill
          * @default 'solid'
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Can set form id to participate in forms. Use this if you need to place submit/reset button outside the form element
         */
        "form"?: string;
        /**
          * Shows a loading spinner and disables the button
          * @default false
         */
        "pending"?: boolean;
        /**
          * Button size
          * @default 'md'
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCalendar {
    }
    interface JeCard {
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * If `true`, the user cannot interact with the element.
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * If the checkbox should contain a 3rd indeterminate state
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * Whether or not the label should go before or after the checkbox
          * @default 'end'
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        /**
          * Emits the current value whenever it's state changes
         */
        "onValueChange"?: (event: JeCheckboxCustomEvent<boolean | undefined>) => void;
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color;
        /**
          * Color in dark mode
         */
        "dark"?: Color;
        /**
          * Color in light mode
         */
        "light"?: Color;
    }
    interface JeComp {
    }
    interface JeControl {
    }
    interface JeDatepicker {
        /**
          * @default false
         */
        "includeSeconds"?: boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        "onValueChange"?: (event: JeDatepickerCustomEvent<number>) => void;
        /**
          * @default "datetime"
         */
        "type"?: "date" | "datetime" | "time";
        "value"?: number;
    }
    interface JeDaw {
    }
    interface JeDetails {
        /**
          * @default "right"
         */
        "iconSide"?: "left" | "right";
        /**
          * @default false
         */
        "iconToggle"?: boolean;
        "onCollapse"?: (event: JeDetailsCustomEvent<any>) => void;
        "onExpand"?: (event: JeDetailsCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
        "summary"?: string;
    }
    interface JeDiscardForm {
    }
    interface JeDivider {
        /**
          * @default 'md'
         */
        "spacing"?: 'sm' | 'md' | 'lg' | 'none';
        /**
          * @default 'horizontal'
         */
        "type"?: 'horizontal' | 'vertical';
    }
    interface JeDropzone {
        "onDataDrop"?: (event: JeDropzoneCustomEvent<DataTransfer>) => void;
    }
    interface JeEq {
    }
    interface JeForm {
        "onDataSubmit"?: (event: JeFormCustomEvent<Record<string, any>>) => void;
    }
    interface JeGrid {
        "space"?: | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
          * @default false
         */
        "fill"?: boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
          * @default 'md'
         */
        "size"?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
          * @default 400
         */
        "weight"?: number;
    }
    interface JeItem {
    }
    interface JeKnob {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
          * @default false
         */
        "bold"?: boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
          * @default true
         */
        "underline"?: boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeMidi {
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean;
        "value"?: any;
    }
    interface JeOverlay {
        /**
          * Backdrop will close the modal on click when enabled
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * Optionally execute a promise after closing completes
         */
        "destroy"?: () => void | Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Emits whenever the overlay has finished closing. Emits the role and optional data object passed to the hide() method.
         */
        "onDismiss"?: (event: JeOverlayCustomEvent<OverlayData1>) => void;
        /**
          * Emits whenever the overlay has opened. Does not emit any data
         */
        "onPresent"?: (event: JeOverlayCustomEvent<any>) => void;
        /**
          * Opens and closes modal
          * @default false
         */
        "open"?: boolean;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side"?: "left" | "right" | "bottom" | "top";
        /**
          * Size of the overlay
          * @default "md"
         */
        "size"?: "sm" | "md" | "lg";
    }
    interface JePill {
        /**
          * @default false
         */
        "outline"?: boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
          * @default true
         */
        "animated"?: boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
          * @default true
         */
        "arrow"?: boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
          * @default 6
         */
        "arrowPadding"?: number;
        /**
          * Backdrop will dismiss the popover on click when enabled
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
          * @default false
         */
        "dismissOnClick"?: boolean;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
          * @default false
         */
        "matchWidth"?: boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY"?: number;
        /**
          * Emits when the popover is closed
         */
        "onDismissEnd"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits before the popover starts dismissing
         */
        "onDismissStart"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover is opened
         */
        "onPresentEnd"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits before the popover starts opening
         */
        "onPresentStart"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover has completed it's initial render
         */
        "onReady"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Opens/closes the popover
          * @default false
         */
        "open"?: boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
          * @default "element"
         */
        "positionStrategy"?: "click" | "element";
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
          * @default "click"
         */
        "triggerAction"?: "click" | "context-menu" | "hover";
    }
    interface JeRadio {
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value"?: any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Disables the controls
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * Label that shows above the control
         */
        "label"?: string;
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        /**
          * Additional info that shows below the control
         */
        "note"?: string;
        /**
          * Emits the selected value whenever it changes
         */
        "onValueChange"?: (event: JeRadioGroupCustomEvent<any>) => void;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRange {
    }
    interface JeReorderItem {
    }
    interface JeReorderList {
    }
    interface JeRichText {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default '500px'
         */
        "maxHeight"?: string;
        /**
          * @default '200px'
         */
        "minHeight"?: string;
        "onEditorBlur"?: (event: JeRichTextCustomEvent<FocusEvent>) => void;
        "onEditorChange"?: (event: JeRichTextCustomEvent<EditorChangeEvent>) => void;
        "onEditorFocus"?: (event: JeRichTextCustomEvent<FocusEvent>) => void;
        /**
          * @default 'Start typing...'
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly"?: boolean;
        /**
          * @default true
         */
        "showWordCount"?: boolean;
        /**
          * @default ''
         */
        "value"?: string;
    }
    interface JeSelect {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        "label"?: string;
        /**
          * @default false
         */
        "multiple"?: boolean;
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        "note"?: string;
        "onValueChange"?: (event: JeSelectCustomEvent<any>) => void;
        "options"?: { value: any; label: string }[];
        "originalValue"?: any;
        "placeholder"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default "md"
         */
        "size"?: "md" | "lg" | "sm";
        "value"?: any;
    }
    interface JeSplitPanel {
    }
    interface JeSplitView {
    }
    interface JeStack {
        "align"?: string;
        "justify"?: string;
        /**
          * @default "column"
         */
        "mode"?: "row" | "column";
        /**
          * @default "md"
         */
        "space"?: | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeSynth {
    }
    interface JeTab {
        /**
          * @default false
         */
        "active"?: boolean;
        /**
          * If `true`, the user cannot interact with the element.
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        "value"?: string;
    }
    interface JeTable {
        "columns"?: number;
    }
    interface JeTabs {
        /**
          * @default 'segment'
         */
        "mode"?: 'mobile' | 'pill' | 'segment';
        "onValueChange"?: (event: JeTabsCustomEvent<string | undefined>) => void;
        "value"?: string;
    }
    interface JeTc {
        "colSpan"?: number;
        /**
          * @default false
         */
        "copy"?: boolean;
        "rowSpan"?: number;
    }
    interface JeTextfield {
        /**
          * Optional debounce of the didInput event
          * @default 0
         */
        "debounce"?: number;
        /**
          * Renders input as disabled and prevents changes
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * Text above the control
         */
        "label"?: string;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
          * @default false
         */
        "multiline"?: boolean;
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * Emits as the user types
         */
        "onValueChange"?: (event: JeTextfieldCustomEvent<any>) => void;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: any;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
          * @default false
         */
        "required"?: boolean;
        /**
          * Container size
          * @default 'md'
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * @default 'text'
         */
        "type"?: 'text'
    | 'number'
    | 'search'
    | 'email'
    | 'phone'
    | 'url'
    | 'money'
    | 'date'
    | 'time'
    | 'datetime'
    | 'daterange'
    | 'password'
    | 'ssn'
    | Omit<InputMaskOptions, 'inputElement'>;
        /**
          * Current value of the input
         */
        "value"?: any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToc {
    }
    interface JeToggle {
        /**
          * If `true`, the user cannot interact with the element.
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * If the label should be placed at the start or end of the toggle
          * @default 'end'
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * The name of the element, used when submitting an HTML form.
         */
        "name"?: string;
        /**
          * Emits the new value whenever toggle is clicked
         */
        "onValueChange"?: (event: JeToggleCustomEvent<boolean>) => void;
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Whether or not the toggle is active
          * @default false
         */
        "value"?: boolean;
    }
    interface JeToolbar {
        /**
          * @default false
         */
        "flank"?: boolean | "reverse";
        /**
          * @default "row"
         */
        "mode"?: "row" | "column";
        /**
          * @default "md"
         */
        "space"?: | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY"?: number;
    }
    interface JeTr {
        /**
          * @default "body"
         */
        "type"?: "header" | "body" | "footer";
    }
    interface JeTree {
        /**
          * @default false
         */
        "indentation"?: boolean;
        "onValueChange"?: (event: JeTreeCustomEvent<string | string[]>) => void;
        /**
          * @default 'leaf'
         */
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeView {
        /**
          * @default true
         */
        "closable"?: boolean;
        "label"?: string;
    }
    interface JeViewManager {
    }
    interface JeWizard {
        "onFinish"?: (event: JeWizardCustomEvent<void>) => void;
        "onStepChange"?: (event: JeWizardCustomEvent<number>) => void;
        /**
          * @default []
         */
        "steps"?: { label: string, optional?: boolean }[];
    }

    interface JeAlertAttributes {
        "closable": boolean;
        "color": Color;
        "duration": number;
        "open": boolean;
    }
    interface JeBranchAttributes {
        "selection": 'single' | 'multiple' | 'leaf';
        "indentation": boolean;
        "open": boolean;
        "value": string;
        "label": string;
        "selected": boolean | null;
        "href": string;
    }
    interface JeBreadcrumbsAttributes {
        "itemsBeforeCollapse": number;
        "itemsAfterCollapse": number;
        "maxItems": number;
    }
    interface JeButtonAttributes {
        "disabled": boolean;
        "type": 'submit' | 'reset';
        "form": string;
        "expand": boolean;
        "pending": boolean;
        "fill": 'solid' | 'outline' | 'clear';
        "size": 'md' | 'lg' | 'sm';
        "color": Color;
    }
    interface JeCardAttributes {
        "color": Color;
    }
    interface JeCheckboxAttributes {
        "originalValue": boolean;
        "data": string;
        "value": boolean;
        "labelPlacement": 'start' | 'end';
        "indeterminate": boolean;
        "required": boolean;
    }
    interface JeColorAttributes {
        "color": Color;
        "light": Color;
        "dark": Color;
    }
    interface JeDatepickerAttributes {
        "type": "date" | "datetime" | "time";
        "includeSeconds": boolean;
        "min": number;
        "max": number;
        "value": number;
    }
    interface JeDetailsAttributes {
        "summary": string;
        "open": boolean;
        "iconToggle": boolean;
        "iconSide": "left" | "right";
    }
    interface JeDividerAttributes {
        "type": 'horizontal' | 'vertical';
        "spacing": 'sm' | 'md' | 'lg' | 'none';
    }
    interface JeGridAttributes {
        "space": | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeIconAttributes {
        "size": 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        "fill": boolean;
        "grade": 'high' | 'low';
        "weight": number;
    }
    interface JeLabelAttributes {
        "required": boolean;
    }
    interface JeLinkAttributes {
        "underline": boolean;
        "bold": boolean;
        "href": string;
        "target": string;
        "rel": string;
        "download": string;
    }
    interface JeNoteAttributes {
        "invalid": boolean;
    }
    interface JeOptionAttributes {
        "value": string;
        "selected": boolean;
        "disabled": boolean;
    }
    interface JeOverlayAttributes {
        "backdropDismiss": boolean;
        "open": boolean;
        "size": "sm" | "md" | "lg";
        "side": "left" | "right" | "bottom" | "top";
    }
    interface JePillAttributes {
        "outline": boolean;
    }
    interface JePlaceholderAttributes {
        "animated": boolean;
    }
    interface JePopoverAttributes {
        "open": boolean;
        "placement": Placement;
        "backdropDismiss": boolean;
        "dismissOnClick": boolean;
        "positionStrategy": "click" | "element";
        "offsetX": number;
        "offsetY": number;
        "triggerAction": "click" | "context-menu" | "hover";
        "matchWidth": boolean;
        "arrow": boolean;
        "arrowPadding": number;
    }
    interface JeRadioAttributes {
        "value": string;
        "selected": boolean;
    }
    interface JeRadioButtonAttributes {
        "value": string;
        "selected": boolean;
    }
    interface JeRadioGroupAttributes {
        "required": boolean;
        "disabled": boolean;
        "originalValue": string;
        "label": string;
        "note": string;
        "value": string;
    }
    interface JeRichTextAttributes {
        "placeholder": string;
        "value": string;
        "disabled": boolean;
        "readonly": boolean;
        "minHeight": string;
        "maxHeight": string;
        "showWordCount": boolean;
    }
    interface JeSelectAttributes {
        "value": string;
        "label": string;
        "disabled": boolean;
        "required": boolean;
        "placeholder": string;
        "note": string;
        "multiple": boolean;
        "originalValue": string;
        "size": "md" | "lg" | "sm";
    }
    interface JeStackAttributes {
        "mode": "row" | "column";
        "align": string;
        "justify": string;
        "space": | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeTabAttributes {
        "value": string;
        "active": boolean;
    }
    interface JeTableAttributes {
        "columns": number;
    }
    interface JeTabsAttributes {
        "mode": 'mobile' | 'pill' | 'segment';
        "value": string;
    }
    interface JeTcAttributes {
        "colSpan": number;
        "rowSpan": number;
        "copy": boolean;
    }
    interface JeTextfieldAttributes {
        "type": 'text'
    | 'number'
    | 'search'
    | 'email'
    | 'phone'
    | 'url'
    | 'money'
    | 'date'
    | 'time'
    | 'datetime'
    | 'daterange'
    | 'password'
    | 'ssn'
    | Omit<InputMaskOptions, 'inputElement'>;
        "originalValue": string;
        "value": string;
        "label": string;
        "note": string;
        "size": 'md' | 'lg' | 'sm';
        "placeholder": string;
        "debounce": number;
        "disabled": boolean;
        "readonly": boolean;
        "wrap": string;
        "multiline": boolean;
        "min": string;
        "max": string;
        "minlength": number;
        "maxlength": number;
        "pattern": string;
        "required": boolean;
        "step": string;
    }
    interface JeToggleAttributes {
        "originalValue": boolean;
        "value": boolean;
        "labelPlacement": 'start' | 'end';
    }
    interface JeToolbarAttributes {
        "flank": string;
        "mode": "row" | "column";
        "space": | "3xs"
    | "2xs"
    | "xs"
    | "sm"
    | "md"
    | "lg"
    | "xl"
    | "2xs"
    | "3xl";
    }
    interface JeTooltipAttributes {
        "content": string;
        "offsetX": number;
        "offsetY": number;
    }
    interface JeTrAttributes {
        "type": "header" | "body" | "footer";
    }
    interface JeTreeAttributes {
        "value": string | string[];
        "selection": 'single' | 'multiple' | 'leaf';
        "indentation": boolean;
    }
    interface JeViewAttributes {
        "label": string;
        "closable": boolean;
    }

    interface IntrinsicElements {
        "je-accordion": JeAccordion;
        "je-alert": Omit<JeAlert, keyof JeAlertAttributes> & { [K in keyof JeAlert & keyof JeAlertAttributes]?: JeAlert[K] } & { [K in keyof JeAlert & keyof JeAlertAttributes as `attr:${K}`]?: JeAlertAttributes[K] } & { [K in keyof JeAlert & keyof JeAlertAttributes as `prop:${K}`]?: JeAlert[K] };
        "je-branch": Omit<JeBranch, keyof JeBranchAttributes> & { [K in keyof JeBranch & keyof JeBranchAttributes]?: JeBranch[K] } & { [K in keyof JeBranch & keyof JeBranchAttributes as `attr:${K}`]?: JeBranchAttributes[K] } & { [K in keyof JeBranch & keyof JeBranchAttributes as `prop:${K}`]?: JeBranch[K] };
        "je-breadcrumb": JeBreadcrumb;
        "je-breadcrumbs": Omit<JeBreadcrumbs, keyof JeBreadcrumbsAttributes> & { [K in keyof JeBreadcrumbs & keyof JeBreadcrumbsAttributes]?: JeBreadcrumbs[K] } & { [K in keyof JeBreadcrumbs & keyof JeBreadcrumbsAttributes as `attr:${K}`]?: JeBreadcrumbsAttributes[K] } & { [K in keyof JeBreadcrumbs & keyof JeBreadcrumbsAttributes as `prop:${K}`]?: JeBreadcrumbs[K] };
        "je-button": Omit<JeButton, keyof JeButtonAttributes> & { [K in keyof JeButton & keyof JeButtonAttributes]?: JeButton[K] } & { [K in keyof JeButton & keyof JeButtonAttributes as `attr:${K}`]?: JeButtonAttributes[K] } & { [K in keyof JeButton & keyof JeButtonAttributes as `prop:${K}`]?: JeButton[K] };
        "je-button-group": JeButtonGroup;
        "je-calendar": JeCalendar;
        "je-card": Omit<JeCard, keyof JeCardAttributes> & { [K in keyof JeCard & keyof JeCardAttributes]?: JeCard[K] } & { [K in keyof JeCard & keyof JeCardAttributes as `attr:${K}`]?: JeCardAttributes[K] } & { [K in keyof JeCard & keyof JeCardAttributes as `prop:${K}`]?: JeCard[K] };
        "je-checkbox": Omit<JeCheckbox, keyof JeCheckboxAttributes> & { [K in keyof JeCheckbox & keyof JeCheckboxAttributes]?: JeCheckbox[K] } & { [K in keyof JeCheckbox & keyof JeCheckboxAttributes as `attr:${K}`]?: JeCheckboxAttributes[K] } & { [K in keyof JeCheckbox & keyof JeCheckboxAttributes as `prop:${K}`]?: JeCheckbox[K] };
        "je-color": Omit<JeColor, keyof JeColorAttributes> & { [K in keyof JeColor & keyof JeColorAttributes]?: JeColor[K] } & { [K in keyof JeColor & keyof JeColorAttributes as `attr:${K}`]?: JeColorAttributes[K] } & { [K in keyof JeColor & keyof JeColorAttributes as `prop:${K}`]?: JeColor[K] };
        "je-comp": JeComp;
        "je-control": JeControl;
        "je-datepicker": Omit<JeDatepicker, keyof JeDatepickerAttributes> & { [K in keyof JeDatepicker & keyof JeDatepickerAttributes]?: JeDatepicker[K] } & { [K in keyof JeDatepicker & keyof JeDatepickerAttributes as `attr:${K}`]?: JeDatepickerAttributes[K] } & { [K in keyof JeDatepicker & keyof JeDatepickerAttributes as `prop:${K}`]?: JeDatepicker[K] };
        "je-daw": JeDaw;
        "je-details": Omit<JeDetails, keyof JeDetailsAttributes> & { [K in keyof JeDetails & keyof JeDetailsAttributes]?: JeDetails[K] } & { [K in keyof JeDetails & keyof JeDetailsAttributes as `attr:${K}`]?: JeDetailsAttributes[K] } & { [K in keyof JeDetails & keyof JeDetailsAttributes as `prop:${K}`]?: JeDetails[K] };
        "je-discard-form": JeDiscardForm;
        "je-divider": Omit<JeDivider, keyof JeDividerAttributes> & { [K in keyof JeDivider & keyof JeDividerAttributes]?: JeDivider[K] } & { [K in keyof JeDivider & keyof JeDividerAttributes as `attr:${K}`]?: JeDividerAttributes[K] } & { [K in keyof JeDivider & keyof JeDividerAttributes as `prop:${K}`]?: JeDivider[K] };
        "je-dropzone": JeDropzone;
        "je-eq": JeEq;
        "je-form": JeForm;
        "je-grid": Omit<JeGrid, keyof JeGridAttributes> & { [K in keyof JeGrid & keyof JeGridAttributes]?: JeGrid[K] } & { [K in keyof JeGrid & keyof JeGridAttributes as `attr:${K}`]?: JeGridAttributes[K] } & { [K in keyof JeGrid & keyof JeGridAttributes as `prop:${K}`]?: JeGrid[K] };
        "je-icon": Omit<JeIcon, keyof JeIconAttributes> & { [K in keyof JeIcon & keyof JeIconAttributes]?: JeIcon[K] } & { [K in keyof JeIcon & keyof JeIconAttributes as `attr:${K}`]?: JeIconAttributes[K] } & { [K in keyof JeIcon & keyof JeIconAttributes as `prop:${K}`]?: JeIcon[K] };
        "je-item": JeItem;
        "je-knob": JeKnob;
        "je-label": Omit<JeLabel, keyof JeLabelAttributes> & { [K in keyof JeLabel & keyof JeLabelAttributes]?: JeLabel[K] } & { [K in keyof JeLabel & keyof JeLabelAttributes as `attr:${K}`]?: JeLabelAttributes[K] } & { [K in keyof JeLabel & keyof JeLabelAttributes as `prop:${K}`]?: JeLabel[K] };
        "je-link": Omit<JeLink, keyof JeLinkAttributes> & { [K in keyof JeLink & keyof JeLinkAttributes]?: JeLink[K] } & { [K in keyof JeLink & keyof JeLinkAttributes as `attr:${K}`]?: JeLinkAttributes[K] } & { [K in keyof JeLink & keyof JeLinkAttributes as `prop:${K}`]?: JeLink[K] };
        "je-list": JeList;
        "je-loading": JeLoading;
        "je-midi": JeMidi;
        "je-note": Omit<JeNote, keyof JeNoteAttributes> & { [K in keyof JeNote & keyof JeNoteAttributes]?: JeNote[K] } & { [K in keyof JeNote & keyof JeNoteAttributes as `attr:${K}`]?: JeNoteAttributes[K] } & { [K in keyof JeNote & keyof JeNoteAttributes as `prop:${K}`]?: JeNote[K] };
        "je-option": Omit<JeOption, keyof JeOptionAttributes> & { [K in keyof JeOption & keyof JeOptionAttributes]?: JeOption[K] } & { [K in keyof JeOption & keyof JeOptionAttributes as `attr:${K}`]?: JeOptionAttributes[K] } & { [K in keyof JeOption & keyof JeOptionAttributes as `prop:${K}`]?: JeOption[K] };
        "je-overlay": Omit<JeOverlay, keyof JeOverlayAttributes> & { [K in keyof JeOverlay & keyof JeOverlayAttributes]?: JeOverlay[K] } & { [K in keyof JeOverlay & keyof JeOverlayAttributes as `attr:${K}`]?: JeOverlayAttributes[K] } & { [K in keyof JeOverlay & keyof JeOverlayAttributes as `prop:${K}`]?: JeOverlay[K] };
        "je-pill": Omit<JePill, keyof JePillAttributes> & { [K in keyof JePill & keyof JePillAttributes]?: JePill[K] } & { [K in keyof JePill & keyof JePillAttributes as `attr:${K}`]?: JePillAttributes[K] } & { [K in keyof JePill & keyof JePillAttributes as `prop:${K}`]?: JePill[K] };
        "je-placeholder": Omit<JePlaceholder, keyof JePlaceholderAttributes> & { [K in keyof JePlaceholder & keyof JePlaceholderAttributes]?: JePlaceholder[K] } & { [K in keyof JePlaceholder & keyof JePlaceholderAttributes as `attr:${K}`]?: JePlaceholderAttributes[K] } & { [K in keyof JePlaceholder & keyof JePlaceholderAttributes as `prop:${K}`]?: JePlaceholder[K] };
        "je-popover": Omit<JePopover, keyof JePopoverAttributes> & { [K in keyof JePopover & keyof JePopoverAttributes]?: JePopover[K] } & { [K in keyof JePopover & keyof JePopoverAttributes as `attr:${K}`]?: JePopoverAttributes[K] } & { [K in keyof JePopover & keyof JePopoverAttributes as `prop:${K}`]?: JePopover[K] };
        "je-radio": Omit<JeRadio, keyof JeRadioAttributes> & { [K in keyof JeRadio & keyof JeRadioAttributes]?: JeRadio[K] } & { [K in keyof JeRadio & keyof JeRadioAttributes as `attr:${K}`]?: JeRadioAttributes[K] } & { [K in keyof JeRadio & keyof JeRadioAttributes as `prop:${K}`]?: JeRadio[K] };
        "je-radio-button": Omit<JeRadioButton, keyof JeRadioButtonAttributes> & { [K in keyof JeRadioButton & keyof JeRadioButtonAttributes]?: JeRadioButton[K] } & { [K in keyof JeRadioButton & keyof JeRadioButtonAttributes as `attr:${K}`]?: JeRadioButtonAttributes[K] } & { [K in keyof JeRadioButton & keyof JeRadioButtonAttributes as `prop:${K}`]?: JeRadioButton[K] };
        "je-radio-group": Omit<JeRadioGroup, keyof JeRadioGroupAttributes> & { [K in keyof JeRadioGroup & keyof JeRadioGroupAttributes]?: JeRadioGroup[K] } & { [K in keyof JeRadioGroup & keyof JeRadioGroupAttributes as `attr:${K}`]?: JeRadioGroupAttributes[K] } & { [K in keyof JeRadioGroup & keyof JeRadioGroupAttributes as `prop:${K}`]?: JeRadioGroup[K] };
        "je-range": JeRange;
        "je-reorder-item": JeReorderItem;
        "je-reorder-list": JeReorderList;
        "je-rich-text": Omit<JeRichText, keyof JeRichTextAttributes> & { [K in keyof JeRichText & keyof JeRichTextAttributes]?: JeRichText[K] } & { [K in keyof JeRichText & keyof JeRichTextAttributes as `attr:${K}`]?: JeRichTextAttributes[K] } & { [K in keyof JeRichText & keyof JeRichTextAttributes as `prop:${K}`]?: JeRichText[K] };
        "je-select": Omit<JeSelect, keyof JeSelectAttributes> & { [K in keyof JeSelect & keyof JeSelectAttributes]?: JeSelect[K] } & { [K in keyof JeSelect & keyof JeSelectAttributes as `attr:${K}`]?: JeSelectAttributes[K] } & { [K in keyof JeSelect & keyof JeSelectAttributes as `prop:${K}`]?: JeSelect[K] };
        "je-split-panel": JeSplitPanel;
        "je-split-view": JeSplitView;
        "je-stack": Omit<JeStack, keyof JeStackAttributes> & { [K in keyof JeStack & keyof JeStackAttributes]?: JeStack[K] } & { [K in keyof JeStack & keyof JeStackAttributes as `attr:${K}`]?: JeStackAttributes[K] } & { [K in keyof JeStack & keyof JeStackAttributes as `prop:${K}`]?: JeStack[K] };
        "je-synth": JeSynth;
        "je-tab": Omit<JeTab, keyof JeTabAttributes> & { [K in keyof JeTab & keyof JeTabAttributes]?: JeTab[K] } & { [K in keyof JeTab & keyof JeTabAttributes as `attr:${K}`]?: JeTabAttributes[K] } & { [K in keyof JeTab & keyof JeTabAttributes as `prop:${K}`]?: JeTab[K] };
        "je-table": Omit<JeTable, keyof JeTableAttributes> & { [K in keyof JeTable & keyof JeTableAttributes]?: JeTable[K] } & { [K in keyof JeTable & keyof JeTableAttributes as `attr:${K}`]?: JeTableAttributes[K] } & { [K in keyof JeTable & keyof JeTableAttributes as `prop:${K}`]?: JeTable[K] };
        "je-tabs": Omit<JeTabs, keyof JeTabsAttributes> & { [K in keyof JeTabs & keyof JeTabsAttributes]?: JeTabs[K] } & { [K in keyof JeTabs & keyof JeTabsAttributes as `attr:${K}`]?: JeTabsAttributes[K] } & { [K in keyof JeTabs & keyof JeTabsAttributes as `prop:${K}`]?: JeTabs[K] };
        "je-tc": Omit<JeTc, keyof JeTcAttributes> & { [K in keyof JeTc & keyof JeTcAttributes]?: JeTc[K] } & { [K in keyof JeTc & keyof JeTcAttributes as `attr:${K}`]?: JeTcAttributes[K] } & { [K in keyof JeTc & keyof JeTcAttributes as `prop:${K}`]?: JeTc[K] };
        "je-textfield": Omit<JeTextfield, keyof JeTextfieldAttributes> & { [K in keyof JeTextfield & keyof JeTextfieldAttributes]?: JeTextfield[K] } & { [K in keyof JeTextfield & keyof JeTextfieldAttributes as `attr:${K}`]?: JeTextfieldAttributes[K] } & { [K in keyof JeTextfield & keyof JeTextfieldAttributes as `prop:${K}`]?: JeTextfield[K] };
        "je-toc": JeToc;
        "je-toggle": Omit<JeToggle, keyof JeToggleAttributes> & { [K in keyof JeToggle & keyof JeToggleAttributes]?: JeToggle[K] } & { [K in keyof JeToggle & keyof JeToggleAttributes as `attr:${K}`]?: JeToggleAttributes[K] } & { [K in keyof JeToggle & keyof JeToggleAttributes as `prop:${K}`]?: JeToggle[K] };
        "je-toolbar": Omit<JeToolbar, keyof JeToolbarAttributes> & { [K in keyof JeToolbar & keyof JeToolbarAttributes]?: JeToolbar[K] } & { [K in keyof JeToolbar & keyof JeToolbarAttributes as `attr:${K}`]?: JeToolbarAttributes[K] } & { [K in keyof JeToolbar & keyof JeToolbarAttributes as `prop:${K}`]?: JeToolbar[K] };
        "je-tooltip": Omit<JeTooltip, keyof JeTooltipAttributes> & { [K in keyof JeTooltip & keyof JeTooltipAttributes]?: JeTooltip[K] } & { [K in keyof JeTooltip & keyof JeTooltipAttributes as `attr:${K}`]?: JeTooltipAttributes[K] } & { [K in keyof JeTooltip & keyof JeTooltipAttributes as `prop:${K}`]?: JeTooltip[K] };
        "je-tr": Omit<JeTr, keyof JeTrAttributes> & { [K in keyof JeTr & keyof JeTrAttributes]?: JeTr[K] } & { [K in keyof JeTr & keyof JeTrAttributes as `attr:${K}`]?: JeTrAttributes[K] } & { [K in keyof JeTr & keyof JeTrAttributes as `prop:${K}`]?: JeTr[K] };
        "je-tree": Omit<JeTree, keyof JeTreeAttributes> & { [K in keyof JeTree & keyof JeTreeAttributes]?: JeTree[K] } & { [K in keyof JeTree & keyof JeTreeAttributes as `attr:${K}`]?: JeTreeAttributes[K] } & { [K in keyof JeTree & keyof JeTreeAttributes as `prop:${K}`]?: JeTree[K] };
        "je-view": Omit<JeView, keyof JeViewAttributes> & { [K in keyof JeView & keyof JeViewAttributes]?: JeView[K] } & { [K in keyof JeView & keyof JeViewAttributes as `attr:${K}`]?: JeViewAttributes[K] } & { [K in keyof JeView & keyof JeViewAttributes as `prop:${K}`]?: JeView[K] };
        "je-view-manager": JeViewManager;
        "je-wizard": JeWizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Accordions are wrappers for <je-link href="../je-details">JeDetails</je-link>. When an inner detail is opened, the others are automatically closed.
             * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
             */
            "je-accordion": LocalJSX.IntrinsicElements["je-accordion"] & JSXBase.HTMLAttributes<HTMLJeAccordionElement>;
            "je-alert": LocalJSX.IntrinsicElements["je-alert"] & JSXBase.HTMLAttributes<HTMLJeAlertElement>;
            "je-branch": LocalJSX.IntrinsicElements["je-branch"] & JSXBase.HTMLAttributes<HTMLJeBranchElement>;
            "je-breadcrumb": LocalJSX.IntrinsicElements["je-breadcrumb"] & JSXBase.HTMLAttributes<HTMLJeBreadcrumbElement>;
            "je-breadcrumbs": LocalJSX.IntrinsicElements["je-breadcrumbs"] & JSXBase.HTMLAttributes<HTMLJeBreadcrumbsElement>;
            "je-button": LocalJSX.IntrinsicElements["je-button"] & JSXBase.HTMLAttributes<HTMLJeButtonElement>;
            "je-button-group": LocalJSX.IntrinsicElements["je-button-group"] & JSXBase.HTMLAttributes<HTMLJeButtonGroupElement>;
            "je-calendar": LocalJSX.IntrinsicElements["je-calendar"] & JSXBase.HTMLAttributes<HTMLJeCalendarElement>;
            "je-card": LocalJSX.IntrinsicElements["je-card"] & JSXBase.HTMLAttributes<HTMLJeCardElement>;
            "je-checkbox": LocalJSX.IntrinsicElements["je-checkbox"] & JSXBase.HTMLAttributes<HTMLJeCheckboxElement>;
            "je-color": LocalJSX.IntrinsicElements["je-color"] & JSXBase.HTMLAttributes<HTMLJeColorElement>;
            "je-comp": LocalJSX.IntrinsicElements["je-comp"] & JSXBase.HTMLAttributes<HTMLJeCompElement>;
            "je-control": LocalJSX.IntrinsicElements["je-control"] & JSXBase.HTMLAttributes<HTMLJeControlElement>;
            "je-datepicker": LocalJSX.IntrinsicElements["je-datepicker"] & JSXBase.HTMLAttributes<HTMLJeDatepickerElement>;
            "je-daw": LocalJSX.IntrinsicElements["je-daw"] & JSXBase.HTMLAttributes<HTMLJeDawElement>;
            "je-details": LocalJSX.IntrinsicElements["je-details"] & JSXBase.HTMLAttributes<HTMLJeDetailsElement>;
            "je-discard-form": LocalJSX.IntrinsicElements["je-discard-form"] & JSXBase.HTMLAttributes<HTMLJeDiscardFormElement>;
            "je-divider": LocalJSX.IntrinsicElements["je-divider"] & JSXBase.HTMLAttributes<HTMLJeDividerElement>;
            "je-dropzone": LocalJSX.IntrinsicElements["je-dropzone"] & JSXBase.HTMLAttributes<HTMLJeDropzoneElement>;
            "je-eq": LocalJSX.IntrinsicElements["je-eq"] & JSXBase.HTMLAttributes<HTMLJeEqElement>;
            "je-form": LocalJSX.IntrinsicElements["je-form"] & JSXBase.HTMLAttributes<HTMLJeFormElement>;
            "je-grid": LocalJSX.IntrinsicElements["je-grid"] & JSXBase.HTMLAttributes<HTMLJeGridElement>;
            "je-icon": LocalJSX.IntrinsicElements["je-icon"] & JSXBase.HTMLAttributes<HTMLJeIconElement>;
            "je-item": LocalJSX.IntrinsicElements["je-item"] & JSXBase.HTMLAttributes<HTMLJeItemElement>;
            "je-knob": LocalJSX.IntrinsicElements["je-knob"] & JSXBase.HTMLAttributes<HTMLJeKnobElement>;
            "je-label": LocalJSX.IntrinsicElements["je-label"] & JSXBase.HTMLAttributes<HTMLJeLabelElement>;
            "je-link": LocalJSX.IntrinsicElements["je-link"] & JSXBase.HTMLAttributes<HTMLJeLinkElement>;
            "je-list": LocalJSX.IntrinsicElements["je-list"] & JSXBase.HTMLAttributes<HTMLJeListElement>;
            "je-loading": LocalJSX.IntrinsicElements["je-loading"] & JSXBase.HTMLAttributes<HTMLJeLoadingElement>;
            "je-midi": LocalJSX.IntrinsicElements["je-midi"] & JSXBase.HTMLAttributes<HTMLJeMidiElement>;
            "je-note": LocalJSX.IntrinsicElements["je-note"] & JSXBase.HTMLAttributes<HTMLJeNoteElement>;
            "je-option": LocalJSX.IntrinsicElements["je-option"] & JSXBase.HTMLAttributes<HTMLJeOptionElement>;
            "je-overlay": LocalJSX.IntrinsicElements["je-overlay"] & JSXBase.HTMLAttributes<HTMLJeOverlayElement>;
            "je-pill": LocalJSX.IntrinsicElements["je-pill"] & JSXBase.HTMLAttributes<HTMLJePillElement>;
            "je-placeholder": LocalJSX.IntrinsicElements["je-placeholder"] & JSXBase.HTMLAttributes<HTMLJePlaceholderElement>;
            "je-popover": LocalJSX.IntrinsicElements["je-popover"] & JSXBase.HTMLAttributes<HTMLJePopoverElement>;
            "je-radio": LocalJSX.IntrinsicElements["je-radio"] & JSXBase.HTMLAttributes<HTMLJeRadioElement>;
            "je-radio-button": LocalJSX.IntrinsicElements["je-radio-button"] & JSXBase.HTMLAttributes<HTMLJeRadioButtonElement>;
            "je-radio-group": LocalJSX.IntrinsicElements["je-radio-group"] & JSXBase.HTMLAttributes<HTMLJeRadioGroupElement>;
            "je-range": LocalJSX.IntrinsicElements["je-range"] & JSXBase.HTMLAttributes<HTMLJeRangeElement>;
            "je-reorder-item": LocalJSX.IntrinsicElements["je-reorder-item"] & JSXBase.HTMLAttributes<HTMLJeReorderItemElement>;
            "je-reorder-list": LocalJSX.IntrinsicElements["je-reorder-list"] & JSXBase.HTMLAttributes<HTMLJeReorderListElement>;
            "je-rich-text": LocalJSX.IntrinsicElements["je-rich-text"] & JSXBase.HTMLAttributes<HTMLJeRichTextElement>;
            "je-select": LocalJSX.IntrinsicElements["je-select"] & JSXBase.HTMLAttributes<HTMLJeSelectElement>;
            "je-split-panel": LocalJSX.IntrinsicElements["je-split-panel"] & JSXBase.HTMLAttributes<HTMLJeSplitPanelElement>;
            "je-split-view": LocalJSX.IntrinsicElements["je-split-view"] & JSXBase.HTMLAttributes<HTMLJeSplitViewElement>;
            "je-stack": LocalJSX.IntrinsicElements["je-stack"] & JSXBase.HTMLAttributes<HTMLJeStackElement>;
            "je-synth": LocalJSX.IntrinsicElements["je-synth"] & JSXBase.HTMLAttributes<HTMLJeSynthElement>;
            "je-tab": LocalJSX.IntrinsicElements["je-tab"] & JSXBase.HTMLAttributes<HTMLJeTabElement>;
            "je-table": LocalJSX.IntrinsicElements["je-table"] & JSXBase.HTMLAttributes<HTMLJeTableElement>;
            "je-tabs": LocalJSX.IntrinsicElements["je-tabs"] & JSXBase.HTMLAttributes<HTMLJeTabsElement>;
            "je-tc": LocalJSX.IntrinsicElements["je-tc"] & JSXBase.HTMLAttributes<HTMLJeTcElement>;
            "je-textfield": LocalJSX.IntrinsicElements["je-textfield"] & JSXBase.HTMLAttributes<HTMLJeTextfieldElement>;
            "je-toc": LocalJSX.IntrinsicElements["je-toc"] & JSXBase.HTMLAttributes<HTMLJeTocElement>;
            "je-toggle": LocalJSX.IntrinsicElements["je-toggle"] & JSXBase.HTMLAttributes<HTMLJeToggleElement>;
            "je-toolbar": LocalJSX.IntrinsicElements["je-toolbar"] & JSXBase.HTMLAttributes<HTMLJeToolbarElement>;
            "je-tooltip": LocalJSX.IntrinsicElements["je-tooltip"] & JSXBase.HTMLAttributes<HTMLJeTooltipElement>;
            "je-tr": LocalJSX.IntrinsicElements["je-tr"] & JSXBase.HTMLAttributes<HTMLJeTrElement>;
            "je-tree": LocalJSX.IntrinsicElements["je-tree"] & JSXBase.HTMLAttributes<HTMLJeTreeElement>;
            "je-view": LocalJSX.IntrinsicElements["je-view"] & JSXBase.HTMLAttributes<HTMLJeViewElement>;
            "je-view-manager": LocalJSX.IntrinsicElements["je-view-manager"] & JSXBase.HTMLAttributes<HTMLJeViewManagerElement>;
            "je-wizard": LocalJSX.IntrinsicElements["je-wizard"] & JSXBase.HTMLAttributes<HTMLJeWizardElement>;
        }
    }
}
