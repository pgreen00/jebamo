/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { DialogButton, DialogControl } from "./components/je-alert/je-alert";
import { AsyncFormatterFn, AsyncValidationFn, Color, FormatterFn, ValidationFn } from "./utils/utils";
import { Color as Color1 } from "./components";
import { DrawerState } from "./components/je-drawer/je-drawer";
import { PanelState } from "./components/je-page/je-page";
import { Placement } from "@floating-ui/dom";
export { DialogButton, DialogControl } from "./components/je-alert/je-alert";
export { AsyncFormatterFn, AsyncValidationFn, Color, FormatterFn, ValidationFn } from "./utils/utils";
export { Color as Color1 } from "./components";
export { DrawerState } from "./components/je-drawer/je-drawer";
export { PanelState } from "./components/je-page/je-page";
export { Placement } from "@floating-ui/dom";
export namespace Components {
    interface JeAlert {
        /**
          * Whether or not the user can close the dialog by clicking the backdrop
         */
        "backdropClose": boolean;
        /**
          * Buttons for user interaction
         */
        "buttons"?: DialogButton[];
        /**
          * Controls that are wrapped in a form
         */
        "controls"?: DialogControl[];
        "dismiss": (role?: string, data?: any) => Promise<void>;
        /**
          * Title of the dialog
         */
        "header"?: string;
        /**
          * Icon that goes to the left of the header
         */
        "icon"?: string;
        /**
          * Message text below the title
         */
        "message"?: string;
        "present": () => Promise<void>;
        /**
          * Whether or not to render the backdrop
         */
        "showBackdrop": boolean;
        /**
          * Trigger element id
         */
        "trigger"?: string;
    }
    interface JeBranch {
        "getParentBranch": () => Promise<HTMLJeBranchElement | null>;
        "isLeaf": () => Promise<boolean>;
        "label"?: string;
        "open": boolean;
        "selected": boolean | null;
        "value"?: string;
    }
    interface JeButton {
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color": Color | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor": Color;
        /**
          * Disables button
         */
        "disabled": boolean;
        /**
          * Expands the button to the full width of it's container
         */
        "expand": boolean;
        /**
          * Button fill
         */
        "fill": 'solid' | 'outline' | 'clear';
        /**
          * Removes the padding, ideal for turning an icon or image into a button
         */
        "iconOnly": boolean;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor": Color;
        /**
          * Button size
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type": string;
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * Shows the disabled state and prevents changes
         */
        "disabled": boolean;
        /**
          * If the checkbox should contain a 3rd indeterminate state
         */
        "indeterminate": boolean;
        /**
          * Whether or not the label should go before or after the checkbox
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Shows the readonly state and prevents changes
         */
        "readonly": boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
         */
        "required": boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeCheckboxGroup {
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Current selected values
         */
        "value": string[];
    }
    interface JeCheckboxOption {
        /**
          * Whether or not this option is currently checked
         */
        "checked": boolean;
        /**
          * Shows disabled state and prevents changes to this option
         */
        "disabled": boolean;
        /**
          * Shows readonly state and prevents changes to this option
         */
        "readonly": boolean;
        /**
          * Value of this option that the checkbox group will compare against
         */
        "value": any;
    }
    interface JeColor {
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color": Color1 | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor": Color1;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor": Color1;
    }
    interface JeColumn {
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXs"?: string;
    }
    interface JeColumnGroup {
        /**
          * The number of columns the flex grid has.
         */
        "columns"?: number;
    }
    interface JeDatepicker {
        "value"?: Date | string;
    }
    interface JeDetails {
        "state": 'open' | 'closed';
        "summary"?: string;
    }
    interface JeDivider {
        "spacing": 'sm' | 'md' | 'lg' | 'none';
        "type": 'horizontal' | 'vertical';
    }
    interface JeDrawer {
        "side": 'left' | 'right' | 'bottom';
        "state": DrawerState;
    }
    interface JeDropzone {
    }
    interface JeForm {
        /**
          * Removes the default gap between elements passed in
         */
        "gap": 'none' | 'default';
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
         */
        "fill"?: boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Google material icon name
         */
        "icon": string;
        /**
          * Size of the icon
         */
        "size": 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
         */
        "weight"?: number;
    }
    interface JeInfinite {
        /**
          * This must be manually set to true/false to show/hide the intersecting content
         */
        "loading": boolean;
        /**
          * Passed to observer api
         */
        "rootMargin": string;
        /**
          * Threshold passed to observer api
         */
        "threshold": number;
    }
    interface JeInput {
        /**
          * Passed to native input
         */
        "autocapitalize": string;
        /**
          * Passed to native input
         */
        "autocomplete": string;
        /**
          * Passed to native input
         */
        "autocorrect": 'off' | 'on';
        /**
          * Passed to native input
         */
        "autofocus": boolean;
        /**
          * Optional debounce of the didInput event
         */
        "debounce": number;
        /**
          * Renders input as disabled and prevents changes
         */
        "disabled": boolean;
        /**
          * Whether or not the input should expand to the full width of it's container
         */
        "expand"?: boolean;
        /**
          * Formatter function that gets applied directly to the input as the user types. Good for input masking.  If you are using an input masking library, you can use the getInputElement() method to fetch the inner input.
         */
        "format"?: FormatterFn | AsyncFormatterFn;
        "getErrors": () => Promise<{ requiredError: boolean; minLengthError: boolean; maxLengthError: boolean; patternError: boolean; customErrors: string[]; hasError: boolean; }>;
        "getInputElement": () => Promise<HTMLInputElement>;
        /**
          * Helper text directly below the control
         */
        "helperText"?: string;
        /**
          * Passed to native input
         */
        "inputmode": string;
        /**
          * Text above the control
         */
        "label": string;
        "markAsTouched": () => Promise<void>;
        /**
          * Passed to native input
         */
        "max"?: number | string;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: number | string;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Passed to native input
         */
        "multiple": boolean;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Input placeholder text
         */
        "placeholder": string;
        /**
          * Renders input as read only and prevents changes
         */
        "readonly": boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
         */
        "required": boolean;
        "reset": () => Promise<void>;
        /**
          * Passed to native input
         */
        "spellcheck": boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Passed to native input
         */
        "type": string;
        /**
          * Custom validator functions for form participation
         */
        "validators"?: (ValidationFn | AsyncValidationFn)[];
        /**
          * Current value of the input
         */
        "value": string;
    }
    interface JeLink {
        /**
          * Makes text bold
         */
        "bold": boolean;
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color"?: Color1 | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor"?: Color1;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor"?: Color1;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
         */
        "underline": boolean;
    }
    interface JeLoading {
    }
    interface JeMenu {
        "type"?: 'select' | 'radio';
        "value"?: string;
    }
    interface JeMenuOption {
        "checked": boolean;
        "disabled"?: boolean;
        "value"?: string;
    }
    interface JeModal {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropClose": boolean;
        "dismiss": (role?: string, data?: any) => Promise<void>;
        /**
          * Opens and closes modal
         */
        "open": boolean;
        "present": () => Promise<void>;
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop": boolean;
    }
    interface JeMultiselect {
        "expand"?: boolean;
        "label"?: string;
        "placeholder"?: string;
        "required"?: boolean;
        "value": string[];
    }
    interface JeMultiselectOption {
        "checked": boolean;
        "value": string;
    }
    interface JePage {
        "footer": 'sticky' | 'fixed';
        "leftPanel": PanelState;
        "rightPanel": PanelState;
        "theme": 'light' | 'dark' | 'auto';
    }
    interface JePill {
        "button": boolean;
        "disabled": boolean;
        "outline": boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
         */
        "animated": boolean;
    }
    interface JePopover {
        /**
          * Backdrop will dismiss the popover on click when enabled
         */
        "backdropDismiss": boolean;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
         */
        "dismissOnClick": boolean;
        /**
          * If the popover should match the width of the trigger element
         */
        "matchWidth": boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY": number;
        /**
          * Opens/closes the popover
         */
        "open": boolean;
        /**
          * Where the popover should be placed
         */
        "placement": Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
         */
        "positionStrategy": 'click' | 'element';
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop": boolean;
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile. No backdrop will be rendered.
         */
        "triggerAction": 'click' | 'hover' | 'context-menu';
    }
    interface JeRadio {
        /**
          * Whether or not the label will appear before or after the control
         */
        "labelPlacement": 'start' | 'end';
        /**
          * If the option is currently selected
         */
        "selected": boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value": any;
    }
    interface JeRadioGroup {
        /**
          * Shows disabled state for all the controls and prevents changes
         */
        "disabled": boolean;
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Shows readonly state for all the controls and prevents changes
         */
        "readonly": boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeSelect {
        "expand"?: boolean;
        "label"?: string;
        "placeholder"?: string;
        "required"?: boolean;
        "value"?: string;
    }
    interface JeSelectOption {
        "selected": boolean;
        "value": string;
    }
    interface JeTab {
        "active": boolean;
        "value"?: string;
    }
    interface JeTabs {
        "mode": 'mobile' | 'pill' | 'segment';
    }
    interface JeTextarea {
        "debounce": number;
        "disabled"?: boolean;
        "label"?: string;
        "maxLength"?: number;
        "placeholder"?: string;
        "readonly"?: boolean;
        "required"?: boolean;
        "value"?: string;
    }
    interface JeToast {
    }
    interface JeToggle {
        /**
          * Whether or not the toggle is active
         */
        "checked": boolean;
        /**
          * If the label should be placed at the start or end of the toggle
         */
        "labelPlacement": 'start' | 'end';
    }
    interface JeToolbar {
    }
    interface JeTree {
        "indentation": boolean;
        "selection": 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
}
export interface JeAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeAlertElement;
}
export interface JeBranchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeBranchElement;
}
export interface JeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxElement;
}
export interface JeCheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxGroupElement;
}
export interface JeCheckboxOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxOptionElement;
}
export interface JeDatepickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDatepickerElement;
}
export interface JeDropzoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDropzoneElement;
}
export interface JeFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeFormElement;
}
export interface JeInfiniteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeInfiniteElement;
}
export interface JeInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeInputElement;
}
export interface JeMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeMenuElement;
}
export interface JeMenuOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeMenuOptionElement;
}
export interface JeModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeModalElement;
}
export interface JeMultiselectOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeMultiselectOptionElement;
}
export interface JePageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJePageElement;
}
export interface JePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJePopoverElement;
}
export interface JeRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRadioElement;
}
export interface JeRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRadioGroupElement;
}
export interface JeSelectOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeSelectOptionElement;
}
export interface JeTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTabElement;
}
export interface JeToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeToggleElement;
}
export interface JeTreeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTreeElement;
}
declare global {
    interface HTMLJeAlertElementEventMap {
        "didPresent": any;
        "didDismiss": { role: string, data: any };
        "didSubmit": SubmitEvent;
    }
    interface HTMLJeAlertElement extends Components.JeAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeAlertElement: {
        prototype: HTMLJeAlertElement;
        new (): HTMLJeAlertElement;
    };
    interface HTMLJeBranchElementEventMap {
        "branchSelect": string;
    }
    interface HTMLJeBranchElement extends Components.JeBranch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeBranchElementEventMap>(type: K, listener: (this: HTMLJeBranchElement, ev: JeBranchCustomEvent<HTMLJeBranchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeBranchElementEventMap>(type: K, listener: (this: HTMLJeBranchElement, ev: JeBranchCustomEvent<HTMLJeBranchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeBranchElement: {
        prototype: HTMLJeBranchElement;
        new (): HTMLJeBranchElement;
    };
    interface HTMLJeButtonElement extends Components.JeButton, HTMLStencilElement {
    }
    var HTMLJeButtonElement: {
        prototype: HTMLJeButtonElement;
        new (): HTMLJeButtonElement;
    };
    interface HTMLJeCardElement extends Components.JeCard, HTMLStencilElement {
    }
    var HTMLJeCardElement: {
        prototype: HTMLJeCardElement;
        new (): HTMLJeCardElement;
    };
    interface HTMLJeCheckboxElementEventMap {
        "valueChange": boolean | undefined;
    }
    interface HTMLJeCheckboxElement extends Components.JeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxElement: {
        prototype: HTMLJeCheckboxElement;
        new (): HTMLJeCheckboxElement;
    };
    interface HTMLJeCheckboxGroupElementEventMap {
        "valueChange": string[];
    }
    interface HTMLJeCheckboxGroupElement extends Components.JeCheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLJeCheckboxGroupElement, ev: JeCheckboxGroupCustomEvent<HTMLJeCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLJeCheckboxGroupElement, ev: JeCheckboxGroupCustomEvent<HTMLJeCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxGroupElement: {
        prototype: HTMLJeCheckboxGroupElement;
        new (): HTMLJeCheckboxGroupElement;
    };
    interface HTMLJeCheckboxOptionElementEventMap {
        "check": any;
        "uncheck": any;
    }
    interface HTMLJeCheckboxOptionElement extends Components.JeCheckboxOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxOptionElementEventMap>(type: K, listener: (this: HTMLJeCheckboxOptionElement, ev: JeCheckboxOptionCustomEvent<HTMLJeCheckboxOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxOptionElementEventMap>(type: K, listener: (this: HTMLJeCheckboxOptionElement, ev: JeCheckboxOptionCustomEvent<HTMLJeCheckboxOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxOptionElement: {
        prototype: HTMLJeCheckboxOptionElement;
        new (): HTMLJeCheckboxOptionElement;
    };
    interface HTMLJeColorElement extends Components.JeColor, HTMLStencilElement {
    }
    var HTMLJeColorElement: {
        prototype: HTMLJeColorElement;
        new (): HTMLJeColorElement;
    };
    interface HTMLJeColumnElement extends Components.JeColumn, HTMLStencilElement {
    }
    var HTMLJeColumnElement: {
        prototype: HTMLJeColumnElement;
        new (): HTMLJeColumnElement;
    };
    interface HTMLJeColumnGroupElement extends Components.JeColumnGroup, HTMLStencilElement {
    }
    var HTMLJeColumnGroupElement: {
        prototype: HTMLJeColumnGroupElement;
        new (): HTMLJeColumnGroupElement;
    };
    interface HTMLJeDatepickerElementEventMap {
        "valueChange": Date | undefined;
    }
    interface HTMLJeDatepickerElement extends Components.JeDatepicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDatepickerElement: {
        prototype: HTMLJeDatepickerElement;
        new (): HTMLJeDatepickerElement;
    };
    interface HTMLJeDetailsElement extends Components.JeDetails, HTMLStencilElement {
    }
    var HTMLJeDetailsElement: {
        prototype: HTMLJeDetailsElement;
        new (): HTMLJeDetailsElement;
    };
    interface HTMLJeDividerElement extends Components.JeDivider, HTMLStencilElement {
    }
    var HTMLJeDividerElement: {
        prototype: HTMLJeDividerElement;
        new (): HTMLJeDividerElement;
    };
    interface HTMLJeDrawerElement extends Components.JeDrawer, HTMLStencilElement {
    }
    var HTMLJeDrawerElement: {
        prototype: HTMLJeDrawerElement;
        new (): HTMLJeDrawerElement;
    };
    interface HTMLJeDropzoneElementEventMap {
        "dataDrop": DataTransfer;
    }
    interface HTMLJeDropzoneElement extends Components.JeDropzone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDropzoneElement: {
        prototype: HTMLJeDropzoneElement;
        new (): HTMLJeDropzoneElement;
    };
    interface HTMLJeFormElementEventMap {
        "formData": FormData;
    }
    interface HTMLJeFormElement extends Components.JeForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeFormElement: {
        prototype: HTMLJeFormElement;
        new (): HTMLJeFormElement;
    };
    interface HTMLJeIconElement extends Components.JeIcon, HTMLStencilElement {
    }
    var HTMLJeIconElement: {
        prototype: HTMLJeIconElement;
        new (): HTMLJeIconElement;
    };
    interface HTMLJeInfiniteElementEventMap {
        "intersect": void;
    }
    interface HTMLJeInfiniteElement extends Components.JeInfinite, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeInfiniteElementEventMap>(type: K, listener: (this: HTMLJeInfiniteElement, ev: JeInfiniteCustomEvent<HTMLJeInfiniteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeInfiniteElementEventMap>(type: K, listener: (this: HTMLJeInfiniteElement, ev: JeInfiniteCustomEvent<HTMLJeInfiniteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeInfiniteElement: {
        prototype: HTMLJeInfiniteElement;
        new (): HTMLJeInfiniteElement;
    };
    interface HTMLJeInputElementEventMap {
        "valueChange": string;
    }
    interface HTMLJeInputElement extends Components.JeInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeInputElementEventMap>(type: K, listener: (this: HTMLJeInputElement, ev: JeInputCustomEvent<HTMLJeInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeInputElementEventMap>(type: K, listener: (this: HTMLJeInputElement, ev: JeInputCustomEvent<HTMLJeInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeInputElement: {
        prototype: HTMLJeInputElement;
        new (): HTMLJeInputElement;
    };
    interface HTMLJeLinkElement extends Components.JeLink, HTMLStencilElement {
    }
    var HTMLJeLinkElement: {
        prototype: HTMLJeLinkElement;
        new (): HTMLJeLinkElement;
    };
    interface HTMLJeLoadingElement extends Components.JeLoading, HTMLStencilElement {
    }
    var HTMLJeLoadingElement: {
        prototype: HTMLJeLoadingElement;
        new (): HTMLJeLoadingElement;
    };
    interface HTMLJeMenuElementEventMap {
        "valueChange": string;
    }
    interface HTMLJeMenuElement extends Components.JeMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeMenuElementEventMap>(type: K, listener: (this: HTMLJeMenuElement, ev: JeMenuCustomEvent<HTMLJeMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeMenuElementEventMap>(type: K, listener: (this: HTMLJeMenuElement, ev: JeMenuCustomEvent<HTMLJeMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeMenuElement: {
        prototype: HTMLJeMenuElement;
        new (): HTMLJeMenuElement;
    };
    interface HTMLJeMenuOptionElementEventMap {
        "menuOptionSelect": string;
    }
    interface HTMLJeMenuOptionElement extends Components.JeMenuOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeMenuOptionElementEventMap>(type: K, listener: (this: HTMLJeMenuOptionElement, ev: JeMenuOptionCustomEvent<HTMLJeMenuOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeMenuOptionElementEventMap>(type: K, listener: (this: HTMLJeMenuOptionElement, ev: JeMenuOptionCustomEvent<HTMLJeMenuOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeMenuOptionElement: {
        prototype: HTMLJeMenuOptionElement;
        new (): HTMLJeMenuOptionElement;
    };
    interface HTMLJeModalElementEventMap {
        "modalPresent": any;
        "modalDismiss": { role: string, data: any };
    }
    interface HTMLJeModalElement extends Components.JeModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeModalElementEventMap>(type: K, listener: (this: HTMLJeModalElement, ev: JeModalCustomEvent<HTMLJeModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeModalElementEventMap>(type: K, listener: (this: HTMLJeModalElement, ev: JeModalCustomEvent<HTMLJeModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeModalElement: {
        prototype: HTMLJeModalElement;
        new (): HTMLJeModalElement;
    };
    interface HTMLJeMultiselectElement extends Components.JeMultiselect, HTMLStencilElement {
    }
    var HTMLJeMultiselectElement: {
        prototype: HTMLJeMultiselectElement;
        new (): HTMLJeMultiselectElement;
    };
    interface HTMLJeMultiselectOptionElementEventMap {
        "optionChecked": string;
        "optionUnchecked": string;
    }
    interface HTMLJeMultiselectOptionElement extends Components.JeMultiselectOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeMultiselectOptionElementEventMap>(type: K, listener: (this: HTMLJeMultiselectOptionElement, ev: JeMultiselectOptionCustomEvent<HTMLJeMultiselectOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeMultiselectOptionElementEventMap>(type: K, listener: (this: HTMLJeMultiselectOptionElement, ev: JeMultiselectOptionCustomEvent<HTMLJeMultiselectOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeMultiselectOptionElement: {
        prototype: HTMLJeMultiselectOptionElement;
        new (): HTMLJeMultiselectOptionElement;
    };
    interface HTMLJePageElementEventMap {
        "themeChange": 'light' | 'dark';
    }
    interface HTMLJePageElement extends Components.JePage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJePageElementEventMap>(type: K, listener: (this: HTMLJePageElement, ev: JePageCustomEvent<HTMLJePageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJePageElementEventMap>(type: K, listener: (this: HTMLJePageElement, ev: JePageCustomEvent<HTMLJePageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJePageElement: {
        prototype: HTMLJePageElement;
        new (): HTMLJePageElement;
    };
    interface HTMLJePillElement extends Components.JePill, HTMLStencilElement {
    }
    var HTMLJePillElement: {
        prototype: HTMLJePillElement;
        new (): HTMLJePillElement;
    };
    interface HTMLJePlaceholderElement extends Components.JePlaceholder, HTMLStencilElement {
    }
    var HTMLJePlaceholderElement: {
        prototype: HTMLJePlaceholderElement;
        new (): HTMLJePlaceholderElement;
    };
    interface HTMLJePopoverElementEventMap {
        "popoverPresent": any;
        "popoverDismiss": any;
    }
    interface HTMLJePopoverElement extends Components.JePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJePopoverElement: {
        prototype: HTMLJePopoverElement;
        new (): HTMLJePopoverElement;
    };
    interface HTMLJeRadioElementEventMap {
        "radioSelect": any;
    }
    interface HTMLJeRadioElement extends Components.JeRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRadioElementEventMap>(type: K, listener: (this: HTMLJeRadioElement, ev: JeRadioCustomEvent<HTMLJeRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRadioElementEventMap>(type: K, listener: (this: HTMLJeRadioElement, ev: JeRadioCustomEvent<HTMLJeRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRadioElement: {
        prototype: HTMLJeRadioElement;
        new (): HTMLJeRadioElement;
    };
    interface HTMLJeRadioGroupElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeRadioGroupElement extends Components.JeRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRadioGroupElement: {
        prototype: HTMLJeRadioGroupElement;
        new (): HTMLJeRadioGroupElement;
    };
    interface HTMLJeSelectElement extends Components.JeSelect, HTMLStencilElement {
    }
    var HTMLJeSelectElement: {
        prototype: HTMLJeSelectElement;
        new (): HTMLJeSelectElement;
    };
    interface HTMLJeSelectOptionElementEventMap {
        "optionSelected": string;
    }
    interface HTMLJeSelectOptionElement extends Components.JeSelectOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeSelectOptionElementEventMap>(type: K, listener: (this: HTMLJeSelectOptionElement, ev: JeSelectOptionCustomEvent<HTMLJeSelectOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeSelectOptionElementEventMap>(type: K, listener: (this: HTMLJeSelectOptionElement, ev: JeSelectOptionCustomEvent<HTMLJeSelectOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeSelectOptionElement: {
        prototype: HTMLJeSelectOptionElement;
        new (): HTMLJeSelectOptionElement;
    };
    interface HTMLJeTabElementEventMap {
        "tabClick": string;
    }
    interface HTMLJeTabElement extends Components.JeTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTabElementEventMap>(type: K, listener: (this: HTMLJeTabElement, ev: JeTabCustomEvent<HTMLJeTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTabElementEventMap>(type: K, listener: (this: HTMLJeTabElement, ev: JeTabCustomEvent<HTMLJeTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTabElement: {
        prototype: HTMLJeTabElement;
        new (): HTMLJeTabElement;
    };
    interface HTMLJeTabsElement extends Components.JeTabs, HTMLStencilElement {
    }
    var HTMLJeTabsElement: {
        prototype: HTMLJeTabsElement;
        new (): HTMLJeTabsElement;
    };
    interface HTMLJeTextareaElement extends Components.JeTextarea, HTMLStencilElement {
    }
    var HTMLJeTextareaElement: {
        prototype: HTMLJeTextareaElement;
        new (): HTMLJeTextareaElement;
    };
    interface HTMLJeToastElement extends Components.JeToast, HTMLStencilElement {
    }
    var HTMLJeToastElement: {
        prototype: HTMLJeToastElement;
        new (): HTMLJeToastElement;
    };
    interface HTMLJeToggleElementEventMap {
        "toggled": boolean;
    }
    interface HTMLJeToggleElement extends Components.JeToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeToggleElement: {
        prototype: HTMLJeToggleElement;
        new (): HTMLJeToggleElement;
    };
    interface HTMLJeToolbarElement extends Components.JeToolbar, HTMLStencilElement {
    }
    var HTMLJeToolbarElement: {
        prototype: HTMLJeToolbarElement;
        new (): HTMLJeToolbarElement;
    };
    interface HTMLJeTreeElementEventMap {
        "valueChange": string;
    }
    interface HTMLJeTreeElement extends Components.JeTree, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTreeElement: {
        prototype: HTMLJeTreeElement;
        new (): HTMLJeTreeElement;
    };
    interface HTMLElementTagNameMap {
        "je-alert": HTMLJeAlertElement;
        "je-branch": HTMLJeBranchElement;
        "je-button": HTMLJeButtonElement;
        "je-card": HTMLJeCardElement;
        "je-checkbox": HTMLJeCheckboxElement;
        "je-checkbox-group": HTMLJeCheckboxGroupElement;
        "je-checkbox-option": HTMLJeCheckboxOptionElement;
        "je-color": HTMLJeColorElement;
        "je-column": HTMLJeColumnElement;
        "je-column-group": HTMLJeColumnGroupElement;
        "je-datepicker": HTMLJeDatepickerElement;
        "je-details": HTMLJeDetailsElement;
        "je-divider": HTMLJeDividerElement;
        "je-drawer": HTMLJeDrawerElement;
        "je-dropzone": HTMLJeDropzoneElement;
        "je-form": HTMLJeFormElement;
        "je-icon": HTMLJeIconElement;
        "je-infinite": HTMLJeInfiniteElement;
        "je-input": HTMLJeInputElement;
        "je-link": HTMLJeLinkElement;
        "je-loading": HTMLJeLoadingElement;
        "je-menu": HTMLJeMenuElement;
        "je-menu-option": HTMLJeMenuOptionElement;
        "je-modal": HTMLJeModalElement;
        "je-multiselect": HTMLJeMultiselectElement;
        "je-multiselect-option": HTMLJeMultiselectOptionElement;
        "je-page": HTMLJePageElement;
        "je-pill": HTMLJePillElement;
        "je-placeholder": HTMLJePlaceholderElement;
        "je-popover": HTMLJePopoverElement;
        "je-radio": HTMLJeRadioElement;
        "je-radio-group": HTMLJeRadioGroupElement;
        "je-select": HTMLJeSelectElement;
        "je-select-option": HTMLJeSelectOptionElement;
        "je-tab": HTMLJeTabElement;
        "je-tabs": HTMLJeTabsElement;
        "je-textarea": HTMLJeTextareaElement;
        "je-toast": HTMLJeToastElement;
        "je-toggle": HTMLJeToggleElement;
        "je-toolbar": HTMLJeToolbarElement;
        "je-tree": HTMLJeTreeElement;
    }
}
declare namespace LocalJSX {
    interface JeAlert {
        /**
          * Whether or not the user can close the dialog by clicking the backdrop
         */
        "backdropClose"?: boolean;
        /**
          * Buttons for user interaction
         */
        "buttons"?: DialogButton[];
        /**
          * Controls that are wrapped in a form
         */
        "controls"?: DialogControl[];
        /**
          * Title of the dialog
         */
        "header"?: string;
        /**
          * Icon that goes to the left of the header
         */
        "icon"?: string;
        /**
          * Message text below the title
         */
        "message"?: string;
        /**
          * Emitted when the dialog is dismissed
         */
        "onDidDismiss"?: (event: JeAlertCustomEvent<{ role: string, data: any }>) => void;
        /**
          * Emitted when the dialog is presented
         */
        "onDidPresent"?: (event: JeAlertCustomEvent<any>) => void;
        /**
          * Emitted when the inner form submission is triggered
         */
        "onDidSubmit"?: (event: JeAlertCustomEvent<SubmitEvent>) => void;
        /**
          * Whether or not to render the backdrop
         */
        "showBackdrop"?: boolean;
        /**
          * Trigger element id
         */
        "trigger"?: string;
    }
    interface JeBranch {
        "label"?: string;
        "onBranchSelect"?: (event: JeBranchCustomEvent<string>) => void;
        "open"?: boolean;
        "selected"?: boolean | null;
        "value"?: string;
    }
    interface JeButton {
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color"?: Color | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor"?: Color;
        /**
          * Disables button
         */
        "disabled"?: boolean;
        /**
          * Expands the button to the full width of it's container
         */
        "expand"?: boolean;
        /**
          * Button fill
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Removes the padding, ideal for turning an icon or image into a button
         */
        "iconOnly"?: boolean;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor"?: Color;
        /**
          * Button size
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: string;
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * Shows the disabled state and prevents changes
         */
        "disabled"?: boolean;
        /**
          * If the checkbox should contain a 3rd indeterminate state
         */
        "indeterminate"?: boolean;
        /**
          * Whether or not the label should go before or after the checkbox
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the current value whenever it's state changes
         */
        "onValueChange"?: (event: JeCheckboxCustomEvent<boolean | undefined>) => void;
        /**
          * Shows the readonly state and prevents changes
         */
        "readonly"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
         */
        "required"?: boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeCheckboxGroup {
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Emits the current selected values whenever they change
         */
        "onValueChange"?: (event: JeCheckboxGroupCustomEvent<string[]>) => void;
        /**
          * Current selected values
         */
        "value"?: string[];
    }
    interface JeCheckboxOption {
        /**
          * Whether or not this option is currently checked
         */
        "checked"?: boolean;
        /**
          * Shows disabled state and prevents changes to this option
         */
        "disabled"?: boolean;
        /**
          * Emits the value whenever it is checked
         */
        "onCheck"?: (event: JeCheckboxOptionCustomEvent<any>) => void;
        /**
          * Emits the value whenever it is unchecked
         */
        "onUncheck"?: (event: JeCheckboxOptionCustomEvent<any>) => void;
        /**
          * Shows readonly state and prevents changes to this option
         */
        "readonly"?: boolean;
        /**
          * Value of this option that the checkbox group will compare against
         */
        "value"?: any;
    }
    interface JeColor {
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color"?: Color1 | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor"?: Color1;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor"?: Color1;
    }
    interface JeColumn {
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXs"?: string;
    }
    interface JeColumnGroup {
        /**
          * The number of columns the flex grid has.
         */
        "columns"?: number;
    }
    interface JeDatepicker {
        "onValueChange"?: (event: JeDatepickerCustomEvent<Date | undefined>) => void;
        "value"?: Date | string;
    }
    interface JeDetails {
        "state"?: 'open' | 'closed';
        "summary"?: string;
    }
    interface JeDivider {
        "spacing"?: 'sm' | 'md' | 'lg' | 'none';
        "type"?: 'horizontal' | 'vertical';
    }
    interface JeDrawer {
        "side"?: 'left' | 'right' | 'bottom';
        "state"?: DrawerState;
    }
    interface JeDropzone {
        "onDataDrop"?: (event: JeDropzoneCustomEvent<DataTransfer>) => void;
    }
    interface JeForm {
        /**
          * Removes the default gap between elements passed in
         */
        "gap"?: 'none' | 'default';
        "onFormData"?: (event: JeFormCustomEvent<FormData>) => void;
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
         */
        "fill"?: boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Google material icon name
         */
        "icon"?: string;
        /**
          * Size of the icon
         */
        "size"?: 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
         */
        "weight"?: number;
    }
    interface JeInfinite {
        /**
          * This must be manually set to true/false to show/hide the intersecting content
         */
        "loading"?: boolean;
        /**
          * Emitted when the bottom of the scroll container is in the viewport
         */
        "onIntersect"?: (event: JeInfiniteCustomEvent<void>) => void;
        /**
          * Passed to observer api
         */
        "rootMargin"?: string;
        /**
          * Threshold passed to observer api
         */
        "threshold"?: number;
    }
    interface JeInput {
        /**
          * Passed to native input
         */
        "autocapitalize"?: string;
        /**
          * Passed to native input
         */
        "autocomplete"?: string;
        /**
          * Passed to native input
         */
        "autocorrect"?: 'off' | 'on';
        /**
          * Passed to native input
         */
        "autofocus"?: boolean;
        /**
          * Optional debounce of the didInput event
         */
        "debounce"?: number;
        /**
          * Renders input as disabled and prevents changes
         */
        "disabled"?: boolean;
        /**
          * Whether or not the input should expand to the full width of it's container
         */
        "expand"?: boolean;
        /**
          * Formatter function that gets applied directly to the input as the user types. Good for input masking.  If you are using an input masking library, you can use the getInputElement() method to fetch the inner input.
         */
        "format"?: FormatterFn | AsyncFormatterFn;
        /**
          * Helper text directly below the control
         */
        "helperText"?: string;
        /**
          * Passed to native input
         */
        "inputmode"?: string;
        /**
          * Text above the control
         */
        "label"?: string;
        /**
          * Passed to native input
         */
        "max"?: number | string;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: number | string;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Passed to native input
         */
        "multiple"?: boolean;
        /**
          * Emits as the user types
         */
        "onValueChange"?: (event: JeInputCustomEvent<string>) => void;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
         */
        "readonly"?: boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
         */
        "required"?: boolean;
        /**
          * Passed to native input
         */
        "spellcheck"?: boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Passed to native input
         */
        "type"?: string;
        /**
          * Custom validator functions for form participation
         */
        "validators"?: (ValidationFn | AsyncValidationFn)[];
        /**
          * Current value of the input
         */
        "value"?: string;
    }
    interface JeLink {
        /**
          * Makes text bold
         */
        "bold"?: boolean;
        /**
          * Predefined colors. Auto will switch between light and dark based on the closest je-page's theme.
         */
        "color"?: Color1 | 'auto';
        /**
          * Overrides what the dark mode color will be when color is "auto".
         */
        "darkModeColor"?: Color1;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Overrides what the light mode color will be when color is "auto".
         */
        "lightModeColor"?: Color1;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
         */
        "underline"?: boolean;
    }
    interface JeLoading {
    }
    interface JeMenu {
        "onValueChange"?: (event: JeMenuCustomEvent<string>) => void;
        "type"?: 'select' | 'radio';
        "value"?: string;
    }
    interface JeMenuOption {
        "checked"?: boolean;
        "disabled"?: boolean;
        "onMenuOptionSelect"?: (event: JeMenuOptionCustomEvent<string>) => void;
        "value"?: string;
    }
    interface JeModal {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropClose"?: boolean;
        /**
          * Emits whenever the modal has finished closing. Emits the role and optional data object passed to the closeModal() method.
         */
        "onModalDismiss"?: (event: JeModalCustomEvent<{ role: string, data: any }>) => void;
        /**
          * Emits whenever the modal has opened. Does not emit any data
         */
        "onModalPresent"?: (event: JeModalCustomEvent<any>) => void;
        /**
          * Opens and closes modal
         */
        "open"?: boolean;
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop"?: boolean;
    }
    interface JeMultiselect {
        "expand"?: boolean;
        "label"?: string;
        "placeholder"?: string;
        "required"?: boolean;
        "value"?: string[];
    }
    interface JeMultiselectOption {
        "checked"?: boolean;
        "onOptionChecked"?: (event: JeMultiselectOptionCustomEvent<string>) => void;
        "onOptionUnchecked"?: (event: JeMultiselectOptionCustomEvent<string>) => void;
        "value"?: string;
    }
    interface JePage {
        "footer"?: 'sticky' | 'fixed';
        "leftPanel"?: PanelState;
        "onThemeChange"?: (event: JePageCustomEvent<'light' | 'dark'>) => void;
        "rightPanel"?: PanelState;
        "theme"?: 'light' | 'dark' | 'auto';
    }
    interface JePill {
        "button"?: boolean;
        "disabled"?: boolean;
        "outline"?: boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
         */
        "animated"?: boolean;
    }
    interface JePopover {
        /**
          * Backdrop will dismiss the popover on click when enabled
         */
        "backdropDismiss"?: boolean;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
         */
        "dismissOnClick"?: boolean;
        /**
          * If the popover should match the width of the trigger element
         */
        "matchWidth"?: boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY"?: number;
        /**
          * Emits when the popover is closed
         */
        "onPopoverDismiss"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover is opened
         */
        "onPopoverPresent"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Opens/closes the popover
         */
        "open"?: boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
         */
        "positionStrategy"?: 'click' | 'element';
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop"?: boolean;
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile. No backdrop will be rendered.
         */
        "triggerAction"?: 'click' | 'hover' | 'context-menu';
    }
    interface JeRadio {
        /**
          * Whether or not the label will appear before or after the control
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the value whenever it is selected
         */
        "onRadioSelect"?: (event: JeRadioCustomEvent<any>) => void;
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value"?: any;
    }
    interface JeRadioGroup {
        /**
          * Shows disabled state for all the controls and prevents changes
         */
        "disabled"?: boolean;
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Emits the selected value whenever it changes
         */
        "onValueChange"?: (event: JeRadioGroupCustomEvent<any>) => void;
        /**
          * Shows readonly state for all the controls and prevents changes
         */
        "readonly"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeSelect {
        "expand"?: boolean;
        "label"?: string;
        "placeholder"?: string;
        "required"?: boolean;
        "value"?: string;
    }
    interface JeSelectOption {
        "onOptionSelected"?: (event: JeSelectOptionCustomEvent<string>) => void;
        "selected"?: boolean;
        "value"?: string;
    }
    interface JeTab {
        "active"?: boolean;
        "onTabClick"?: (event: JeTabCustomEvent<string>) => void;
        "value"?: string;
    }
    interface JeTabs {
        "mode"?: 'mobile' | 'pill' | 'segment';
    }
    interface JeTextarea {
        "debounce"?: number;
        "disabled"?: boolean;
        "label"?: string;
        "maxLength"?: number;
        "placeholder"?: string;
        "readonly"?: boolean;
        "required"?: boolean;
        "value"?: string;
    }
    interface JeToast {
    }
    interface JeToggle {
        /**
          * Whether or not the toggle is active
         */
        "checked"?: boolean;
        /**
          * If the label should be placed at the start or end of the toggle
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the new value whenever toggle is clicked
         */
        "onToggled"?: (event: JeToggleCustomEvent<boolean>) => void;
    }
    interface JeToolbar {
    }
    interface JeTree {
        "indentation"?: boolean;
        "onValueChange"?: (event: JeTreeCustomEvent<string>) => void;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface IntrinsicElements {
        "je-alert": JeAlert;
        "je-branch": JeBranch;
        "je-button": JeButton;
        "je-card": JeCard;
        "je-checkbox": JeCheckbox;
        "je-checkbox-group": JeCheckboxGroup;
        "je-checkbox-option": JeCheckboxOption;
        "je-color": JeColor;
        "je-column": JeColumn;
        "je-column-group": JeColumnGroup;
        "je-datepicker": JeDatepicker;
        "je-details": JeDetails;
        "je-divider": JeDivider;
        "je-drawer": JeDrawer;
        "je-dropzone": JeDropzone;
        "je-form": JeForm;
        "je-icon": JeIcon;
        "je-infinite": JeInfinite;
        "je-input": JeInput;
        "je-link": JeLink;
        "je-loading": JeLoading;
        "je-menu": JeMenu;
        "je-menu-option": JeMenuOption;
        "je-modal": JeModal;
        "je-multiselect": JeMultiselect;
        "je-multiselect-option": JeMultiselectOption;
        "je-page": JePage;
        "je-pill": JePill;
        "je-placeholder": JePlaceholder;
        "je-popover": JePopover;
        "je-radio": JeRadio;
        "je-radio-group": JeRadioGroup;
        "je-select": JeSelect;
        "je-select-option": JeSelectOption;
        "je-tab": JeTab;
        "je-tabs": JeTabs;
        "je-textarea": JeTextarea;
        "je-toast": JeToast;
        "je-toggle": JeToggle;
        "je-toolbar": JeToolbar;
        "je-tree": JeTree;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "je-alert": LocalJSX.JeAlert & JSXBase.HTMLAttributes<HTMLJeAlertElement>;
            "je-branch": LocalJSX.JeBranch & JSXBase.HTMLAttributes<HTMLJeBranchElement>;
            "je-button": LocalJSX.JeButton & JSXBase.HTMLAttributes<HTMLJeButtonElement>;
            "je-card": LocalJSX.JeCard & JSXBase.HTMLAttributes<HTMLJeCardElement>;
            "je-checkbox": LocalJSX.JeCheckbox & JSXBase.HTMLAttributes<HTMLJeCheckboxElement>;
            "je-checkbox-group": LocalJSX.JeCheckboxGroup & JSXBase.HTMLAttributes<HTMLJeCheckboxGroupElement>;
            "je-checkbox-option": LocalJSX.JeCheckboxOption & JSXBase.HTMLAttributes<HTMLJeCheckboxOptionElement>;
            "je-color": LocalJSX.JeColor & JSXBase.HTMLAttributes<HTMLJeColorElement>;
            "je-column": LocalJSX.JeColumn & JSXBase.HTMLAttributes<HTMLJeColumnElement>;
            "je-column-group": LocalJSX.JeColumnGroup & JSXBase.HTMLAttributes<HTMLJeColumnGroupElement>;
            "je-datepicker": LocalJSX.JeDatepicker & JSXBase.HTMLAttributes<HTMLJeDatepickerElement>;
            "je-details": LocalJSX.JeDetails & JSXBase.HTMLAttributes<HTMLJeDetailsElement>;
            "je-divider": LocalJSX.JeDivider & JSXBase.HTMLAttributes<HTMLJeDividerElement>;
            "je-drawer": LocalJSX.JeDrawer & JSXBase.HTMLAttributes<HTMLJeDrawerElement>;
            "je-dropzone": LocalJSX.JeDropzone & JSXBase.HTMLAttributes<HTMLJeDropzoneElement>;
            "je-form": LocalJSX.JeForm & JSXBase.HTMLAttributes<HTMLJeFormElement>;
            "je-icon": LocalJSX.JeIcon & JSXBase.HTMLAttributes<HTMLJeIconElement>;
            "je-infinite": LocalJSX.JeInfinite & JSXBase.HTMLAttributes<HTMLJeInfiniteElement>;
            "je-input": LocalJSX.JeInput & JSXBase.HTMLAttributes<HTMLJeInputElement>;
            "je-link": LocalJSX.JeLink & JSXBase.HTMLAttributes<HTMLJeLinkElement>;
            "je-loading": LocalJSX.JeLoading & JSXBase.HTMLAttributes<HTMLJeLoadingElement>;
            "je-menu": LocalJSX.JeMenu & JSXBase.HTMLAttributes<HTMLJeMenuElement>;
            "je-menu-option": LocalJSX.JeMenuOption & JSXBase.HTMLAttributes<HTMLJeMenuOptionElement>;
            "je-modal": LocalJSX.JeModal & JSXBase.HTMLAttributes<HTMLJeModalElement>;
            "je-multiselect": LocalJSX.JeMultiselect & JSXBase.HTMLAttributes<HTMLJeMultiselectElement>;
            "je-multiselect-option": LocalJSX.JeMultiselectOption & JSXBase.HTMLAttributes<HTMLJeMultiselectOptionElement>;
            "je-page": LocalJSX.JePage & JSXBase.HTMLAttributes<HTMLJePageElement>;
            "je-pill": LocalJSX.JePill & JSXBase.HTMLAttributes<HTMLJePillElement>;
            "je-placeholder": LocalJSX.JePlaceholder & JSXBase.HTMLAttributes<HTMLJePlaceholderElement>;
            "je-popover": LocalJSX.JePopover & JSXBase.HTMLAttributes<HTMLJePopoverElement>;
            "je-radio": LocalJSX.JeRadio & JSXBase.HTMLAttributes<HTMLJeRadioElement>;
            "je-radio-group": LocalJSX.JeRadioGroup & JSXBase.HTMLAttributes<HTMLJeRadioGroupElement>;
            "je-select": LocalJSX.JeSelect & JSXBase.HTMLAttributes<HTMLJeSelectElement>;
            "je-select-option": LocalJSX.JeSelectOption & JSXBase.HTMLAttributes<HTMLJeSelectOptionElement>;
            "je-tab": LocalJSX.JeTab & JSXBase.HTMLAttributes<HTMLJeTabElement>;
            "je-tabs": LocalJSX.JeTabs & JSXBase.HTMLAttributes<HTMLJeTabsElement>;
            "je-textarea": LocalJSX.JeTextarea & JSXBase.HTMLAttributes<HTMLJeTextareaElement>;
            "je-toast": LocalJSX.JeToast & JSXBase.HTMLAttributes<HTMLJeToastElement>;
            "je-toggle": LocalJSX.JeToggle & JSXBase.HTMLAttributes<HTMLJeToggleElement>;
            "je-toolbar": LocalJSX.JeToolbar & JSXBase.HTMLAttributes<HTMLJeToolbarElement>;
            "je-tree": LocalJSX.JeTree & JSXBase.HTMLAttributes<HTMLJeTreeElement>;
        }
    }
}
