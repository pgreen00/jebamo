/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Color, OverlayData } from "./utils/utils";
import { Color as Color1 } from "./components";
import { Placement } from "@floating-ui/dom";
import { FormatterFn, InputTransformer, ValidationFn } from "./components/je-textfield/je-textfield";
export { Color, OverlayData } from "./utils/utils";
export { Color as Color1 } from "./components";
export { Placement } from "@floating-ui/dom";
export { FormatterFn, InputTransformer, ValidationFn } from "./components/je-textfield/je-textfield";
export namespace Components {
    interface JeAccordion {
    }
    interface JeActionSheet {
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Maximum height (expanded fullscreen).
         */
        "maxPercent": number;
        /**
          * Intermediate height (mid state).
         */
        "midPercent": number;
        /**
          * Minimum height (collapsed state).
         */
        "minPercent": number;
        /**
          * Opens and closes modal
         */
        "open": boolean;
        "show": () => Promise<void>;
    }
    interface JeAlert {
        "closable": boolean;
        "color": Color;
        "didDismiss": () => Promise<OverlayData>;
        "duration": number;
        "header"?: string;
        "hide": (role?: string, data?: any) => Promise<void>;
        "icon"?: string;
        "message"?: string;
        "open": boolean;
        "progress": boolean;
        "show": () => Promise<void>;
    }
    interface JeBranch {
        "indentation": boolean;
        "isLeaf": () => Promise<boolean>;
        "label"?: string;
        "open": boolean;
        "selected": boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        "itemsAfterCollapse": number;
        "itemsBeforeCollapse": number;
        "maxItems"?: number;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
         */
        "disabled": boolean;
        /**
          * Expands the button to the full width of it's container
         */
        "expand": boolean;
        /**
          * Button fill
         */
        "fill": 'solid' | 'outline' | 'clear';
        /**
          * Shows a loading spinner and disables the button
         */
        "pending": boolean;
        /**
          * Button size
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * Shows the disabled state and prevents changes
         */
        "disabled": boolean;
        /**
          * If the checkbox should contain a 3rd indeterminate state
         */
        "indeterminate": boolean;
        /**
          * Whether or not the label should go before or after the checkbox
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
         */
        "required": boolean;
        /**
          * Renders the component as a on/off switch rather than a checkbox.
         */
        "switch": boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color1;
        /**
          * Color in dark mode
         */
        "dark"?: Color1;
        /**
          * Color in light mode
         */
        "light"?: Color1;
    }
    interface JeColumn {
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXs"?: string;
    }
    interface JeColumnGroup {
        /**
          * Alignment of the columns.
         */
        "align"?: 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * The number of columns the flex grid has.
         */
        "columns"?: number;
        /**
          * The gap between the columns.
         */
        "gap"?: '3xs' | '2xs' |'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl';
        /**
          * Justification of the columns.
         */
        "justify"?: 'start' | 'center' | 'end' | 'space-between' | 'space-around';
        /**
          * If the columns should wrap.
         */
        "wrap"?: boolean;
    }
    interface JeDatepicker {
        "includeSeconds": boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        "type": 'date' | 'datetime' | 'time';
        "value"?: number;
    }
    interface JeDetails {
        "iconSide": 'left' | 'right';
        "iconToggle": boolean;
        "open": boolean;
        "summary"?: string;
    }
    interface JeDivider {
        "spacing": 'sm' | 'md' | 'lg' | 'none';
        "type": 'horizontal' | 'vertical';
    }
    interface JeDrawer {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropDismiss": boolean;
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Opens and closes modal
         */
        "open": boolean;
        "show": () => Promise<void>;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side": 'left' | 'right';
    }
    interface JeDropzone {
    }
    interface JeForm {
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
         */
        "fill": boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
         */
        "size": 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
         */
        "weight": number;
    }
    interface JeIconButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
         */
        "disabled": boolean;
        /**
          * Button fill
         */
        "fill": 'solid' | 'outline' | 'clear';
        /**
          * Name of icon
         */
        "icon"?: string;
        /**
          * Shows a loading spinner and disables the button
         */
        "pending": boolean;
        /**
          * Button size
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeInfinite {
        /**
          * This must be manually set to true/false to show/hide the intersecting content
         */
        "loading": boolean;
        /**
          * Passed to observer api
         */
        "rootMargin": string;
        /**
          * Threshold passed to observer api
         */
        "threshold": number;
    }
    interface JeItem {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
         */
        "bold": boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
         */
        "underline": boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeModal {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropDismiss": boolean;
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        "didDismiss": () => Promise<OverlayData>;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Opens and closes modal
         */
        "open": boolean;
        "show": () => Promise<void>;
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop": boolean;
        /**
          * Size of the modal
         */
        "size": 'sm' | 'md' | 'lg';
    }
    interface JeNav {
        "mode": 'top' | 'side';
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
    }
    interface JePage {
        /**
          * Changes certain aspects of the page layout. - Sticky will make the entire page scrollable, and the footer will not be visible when the page is overflowing - Flex will make the main element scrollable, and the footer will always be visible
         */
        "layout": 'sticky' | 'flex';
    }
    interface JePill {
        "button": boolean;
        "disabled": boolean;
        "outline": boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
         */
        "animated": boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
         */
        "arrow": boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
         */
        "arrowPadding": number;
        /**
          * Backdrop will dismiss the popover on click when enabled
         */
        "backdropDismiss": boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
         */
        "dismissOnClick": boolean;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
         */
        "matchWidth": boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY": number;
        /**
          * Opens/closes the popover
         */
        "open": boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
         */
        "positionStrategy": 'click' | 'element';
        "show": () => Promise<void>;
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
         */
        "triggerAction": 'click' | 'context-menu' | 'hover';
    }
    interface JeRadio {
        /**
          * Disables option and shows state
         */
        "disabled": boolean;
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value": any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
         */
        "selected": boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRefresher {
    }
    interface JeSelect {
    }
    interface JeTab {
        "active": boolean;
        "value"?: string;
    }
    interface JeTabs {
        "mode": 'mobile' | 'pill' | 'segment';
        "value"?: string;
    }
    interface JeTextfield {
        /**
          * Passed to native input
         */
        "autoCapitalize": string;
        /**
          * Passed to native input
         */
        "autoComplete": string;
        /**
          * Passed to native input
         */
        "autoCorrect": 'off' | 'on';
        /**
          * Passed to native input
         */
        "autoFocus"?: boolean;
        /**
          * Optional debounce of the didInput event
         */
        "debounce": number;
        /**
          * Renders input as disabled and prevents changes
         */
        "disabled": boolean;
        /**
          * Shows an error icon in the end slot when true. If a string is passed in, it will render the icon as a tooltip. Has no effect on form validation
         */
        "error": any;
        /**
          * Formatters functions that are applied as the user types
         */
        "format"?: FormatterFn;
        "getErrors": () => Promise<{ requiredError: boolean; minLengthError: boolean; maxLengthError: boolean; patternError: boolean; customErrors: string[]; hasError: boolean; }>;
        "getInputElement": () => Promise<HTMLInputElement | HTMLTextAreaElement>;
        /**
          * Passed to native input
         */
        "inputMode": string;
        "isTouched": () => Promise<boolean>;
        /**
          * Text above the control
         */
        "label"?: string;
        "markAsTouched": () => Promise<void>;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
         */
        "multiline": boolean;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: string;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Shows a loading indicator in the end slot when true
         */
        "pending": boolean;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
         */
        "readonly": boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
         */
        "required": boolean;
        /**
          * Container size
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
         */
        "spellcheck": boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Shows a success icon in the end slot when true. Has no effect on form validation
         */
        "success": boolean;
        /**
          * Transforms the value before it is passed to the input (from) and after the input emits a new value (to).  There are built-in transformers for 'number', 'date', and 'datetime'.
         */
        "transform"?: InputTransformer | 'number' | 'date' | 'datetime';
        /**
          * Passed to native input
         */
        "type": string;
        /**
          * Validator functions for form participation
         */
        "validators"?: ValidationFn[];
        /**
          * Current value of the input
         */
        "value": any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToastContainer {
        "position": 'top' | 'bottom' | 'top-end' | 'top-start' | 'bottom-end' | 'bottom-start';
    }
    interface JeToggle {
        /**
          * Whether or not the toggle is active
         */
        "checked": boolean;
        /**
          * If the label should be placed at the start or end of the toggle
         */
        "labelPlacement": 'start' | 'end';
    }
    interface JeToolbar {
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY": number;
    }
    interface JeTree {
        "indentation": boolean;
        "selection": 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeWizard {
        "canSkip": () => Promise<boolean>;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        "reset": () => Promise<void>;
        "skip": () => Promise<void>;
        "steps": { label: string, optional?: boolean }[];
    }
}
export interface JeActionSheetCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeActionSheetElement;
}
export interface JeAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeAlertElement;
}
export interface JeBreadcrumbsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeBreadcrumbsElement;
}
export interface JeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxElement;
}
export interface JeDatepickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDatepickerElement;
}
export interface JeDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDetailsElement;
}
export interface JeDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDrawerElement;
}
export interface JeDropzoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDropzoneElement;
}
export interface JeFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeFormElement;
}
export interface JeInfiniteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeInfiniteElement;
}
export interface JeModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeModalElement;
}
export interface JePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJePopoverElement;
}
export interface JeRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRadioGroupElement;
}
export interface JeTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTabsElement;
}
export interface JeTextfieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTextfieldElement;
}
export interface JeToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeToggleElement;
}
export interface JeTreeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTreeElement;
}
export interface JeWizardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeWizardElement;
}
declare global {
    interface HTMLJeAccordionElement extends Components.JeAccordion, HTMLStencilElement {
    }
    var HTMLJeAccordionElement: {
        prototype: HTMLJeAccordionElement;
        new (): HTMLJeAccordionElement;
    };
    interface HTMLJeActionSheetElementEventMap {
        "present": any;
        "dismiss": OverlayData;
    }
    interface HTMLJeActionSheetElement extends Components.JeActionSheet, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeActionSheetElementEventMap>(type: K, listener: (this: HTMLJeActionSheetElement, ev: JeActionSheetCustomEvent<HTMLJeActionSheetElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeActionSheetElementEventMap>(type: K, listener: (this: HTMLJeActionSheetElement, ev: JeActionSheetCustomEvent<HTMLJeActionSheetElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeActionSheetElement: {
        prototype: HTMLJeActionSheetElement;
        new (): HTMLJeActionSheetElement;
    };
    interface HTMLJeAlertElementEventMap {
        "present": any;
        "dismiss": OverlayData;
    }
    interface HTMLJeAlertElement extends Components.JeAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeAlertElement: {
        prototype: HTMLJeAlertElement;
        new (): HTMLJeAlertElement;
    };
    interface HTMLJeBranchElement extends Components.JeBranch, HTMLStencilElement {
    }
    var HTMLJeBranchElement: {
        prototype: HTMLJeBranchElement;
        new (): HTMLJeBranchElement;
    };
    interface HTMLJeBreadcrumbElement extends Components.JeBreadcrumb, HTMLStencilElement {
    }
    var HTMLJeBreadcrumbElement: {
        prototype: HTMLJeBreadcrumbElement;
        new (): HTMLJeBreadcrumbElement;
    };
    interface HTMLJeBreadcrumbsElementEventMap {
        "expandClick": any;
    }
    interface HTMLJeBreadcrumbsElement extends Components.JeBreadcrumbs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeBreadcrumbsElement: {
        prototype: HTMLJeBreadcrumbsElement;
        new (): HTMLJeBreadcrumbsElement;
    };
    interface HTMLJeButtonElement extends Components.JeButton, HTMLStencilElement {
    }
    var HTMLJeButtonElement: {
        prototype: HTMLJeButtonElement;
        new (): HTMLJeButtonElement;
    };
    interface HTMLJeButtonGroupElement extends Components.JeButtonGroup, HTMLStencilElement {
    }
    var HTMLJeButtonGroupElement: {
        prototype: HTMLJeButtonGroupElement;
        new (): HTMLJeButtonGroupElement;
    };
    interface HTMLJeCardElement extends Components.JeCard, HTMLStencilElement {
    }
    var HTMLJeCardElement: {
        prototype: HTMLJeCardElement;
        new (): HTMLJeCardElement;
    };
    interface HTMLJeCheckboxElementEventMap {
        "valueChange": boolean | undefined;
    }
    interface HTMLJeCheckboxElement extends Components.JeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxElement: {
        prototype: HTMLJeCheckboxElement;
        new (): HTMLJeCheckboxElement;
    };
    interface HTMLJeColorElement extends Components.JeColor, HTMLStencilElement {
    }
    var HTMLJeColorElement: {
        prototype: HTMLJeColorElement;
        new (): HTMLJeColorElement;
    };
    interface HTMLJeColumnElement extends Components.JeColumn, HTMLStencilElement {
    }
    var HTMLJeColumnElement: {
        prototype: HTMLJeColumnElement;
        new (): HTMLJeColumnElement;
    };
    interface HTMLJeColumnGroupElement extends Components.JeColumnGroup, HTMLStencilElement {
    }
    var HTMLJeColumnGroupElement: {
        prototype: HTMLJeColumnGroupElement;
        new (): HTMLJeColumnGroupElement;
    };
    interface HTMLJeDatepickerElementEventMap {
        "valueChange": number | undefined;
    }
    interface HTMLJeDatepickerElement extends Components.JeDatepicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDatepickerElement: {
        prototype: HTMLJeDatepickerElement;
        new (): HTMLJeDatepickerElement;
    };
    interface HTMLJeDetailsElementEventMap {
        "expand": any;
        "collapse": any;
    }
    interface HTMLJeDetailsElement extends Components.JeDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDetailsElement: {
        prototype: HTMLJeDetailsElement;
        new (): HTMLJeDetailsElement;
    };
    interface HTMLJeDividerElement extends Components.JeDivider, HTMLStencilElement {
    }
    var HTMLJeDividerElement: {
        prototype: HTMLJeDividerElement;
        new (): HTMLJeDividerElement;
    };
    interface HTMLJeDrawerElementEventMap {
        "present": any;
        "dismiss": OverlayData;
        "backdropClick": any;
    }
    interface HTMLJeDrawerElement extends Components.JeDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDrawerElementEventMap>(type: K, listener: (this: HTMLJeDrawerElement, ev: JeDrawerCustomEvent<HTMLJeDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDrawerElementEventMap>(type: K, listener: (this: HTMLJeDrawerElement, ev: JeDrawerCustomEvent<HTMLJeDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDrawerElement: {
        prototype: HTMLJeDrawerElement;
        new (): HTMLJeDrawerElement;
    };
    interface HTMLJeDropzoneElementEventMap {
        "dataDrop": DataTransfer;
    }
    interface HTMLJeDropzoneElement extends Components.JeDropzone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDropzoneElement: {
        prototype: HTMLJeDropzoneElement;
        new (): HTMLJeDropzoneElement;
    };
    interface HTMLJeFormElementEventMap {
        "formData": Record<string, any>;
    }
    interface HTMLJeFormElement extends Components.JeForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeFormElement: {
        prototype: HTMLJeFormElement;
        new (): HTMLJeFormElement;
    };
    interface HTMLJeIconElement extends Components.JeIcon, HTMLStencilElement {
    }
    var HTMLJeIconElement: {
        prototype: HTMLJeIconElement;
        new (): HTMLJeIconElement;
    };
    interface HTMLJeIconButtonElement extends Components.JeIconButton, HTMLStencilElement {
    }
    var HTMLJeIconButtonElement: {
        prototype: HTMLJeIconButtonElement;
        new (): HTMLJeIconButtonElement;
    };
    interface HTMLJeInfiniteElementEventMap {
        "intersect": void;
    }
    interface HTMLJeInfiniteElement extends Components.JeInfinite, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeInfiniteElementEventMap>(type: K, listener: (this: HTMLJeInfiniteElement, ev: JeInfiniteCustomEvent<HTMLJeInfiniteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeInfiniteElementEventMap>(type: K, listener: (this: HTMLJeInfiniteElement, ev: JeInfiniteCustomEvent<HTMLJeInfiniteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeInfiniteElement: {
        prototype: HTMLJeInfiniteElement;
        new (): HTMLJeInfiniteElement;
    };
    interface HTMLJeItemElement extends Components.JeItem, HTMLStencilElement {
    }
    var HTMLJeItemElement: {
        prototype: HTMLJeItemElement;
        new (): HTMLJeItemElement;
    };
    interface HTMLJeLabelElement extends Components.JeLabel, HTMLStencilElement {
    }
    var HTMLJeLabelElement: {
        prototype: HTMLJeLabelElement;
        new (): HTMLJeLabelElement;
    };
    interface HTMLJeLinkElement extends Components.JeLink, HTMLStencilElement {
    }
    var HTMLJeLinkElement: {
        prototype: HTMLJeLinkElement;
        new (): HTMLJeLinkElement;
    };
    interface HTMLJeListElement extends Components.JeList, HTMLStencilElement {
    }
    var HTMLJeListElement: {
        prototype: HTMLJeListElement;
        new (): HTMLJeListElement;
    };
    interface HTMLJeLoadingElement extends Components.JeLoading, HTMLStencilElement {
    }
    var HTMLJeLoadingElement: {
        prototype: HTMLJeLoadingElement;
        new (): HTMLJeLoadingElement;
    };
    interface HTMLJeModalElementEventMap {
        "present": any;
        "dismiss": OverlayData;
        "backdropClick": any;
    }
    interface HTMLJeModalElement extends Components.JeModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeModalElementEventMap>(type: K, listener: (this: HTMLJeModalElement, ev: JeModalCustomEvent<HTMLJeModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeModalElementEventMap>(type: K, listener: (this: HTMLJeModalElement, ev: JeModalCustomEvent<HTMLJeModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeModalElement: {
        prototype: HTMLJeModalElement;
        new (): HTMLJeModalElement;
    };
    interface HTMLJeNavElement extends Components.JeNav, HTMLStencilElement {
    }
    var HTMLJeNavElement: {
        prototype: HTMLJeNavElement;
        new (): HTMLJeNavElement;
    };
    interface HTMLJeNoteElement extends Components.JeNote, HTMLStencilElement {
    }
    var HTMLJeNoteElement: {
        prototype: HTMLJeNoteElement;
        new (): HTMLJeNoteElement;
    };
    interface HTMLJeOptionElement extends Components.JeOption, HTMLStencilElement {
    }
    var HTMLJeOptionElement: {
        prototype: HTMLJeOptionElement;
        new (): HTMLJeOptionElement;
    };
    interface HTMLJePageElement extends Components.JePage, HTMLStencilElement {
    }
    var HTMLJePageElement: {
        prototype: HTMLJePageElement;
        new (): HTMLJePageElement;
    };
    interface HTMLJePillElement extends Components.JePill, HTMLStencilElement {
    }
    var HTMLJePillElement: {
        prototype: HTMLJePillElement;
        new (): HTMLJePillElement;
    };
    interface HTMLJePlaceholderElement extends Components.JePlaceholder, HTMLStencilElement {
    }
    var HTMLJePlaceholderElement: {
        prototype: HTMLJePlaceholderElement;
        new (): HTMLJePlaceholderElement;
    };
    interface HTMLJePopoverElementEventMap {
        "present": any;
        "dismiss": OverlayData;
        "ready": any;
    }
    interface HTMLJePopoverElement extends Components.JePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJePopoverElement: {
        prototype: HTMLJePopoverElement;
        new (): HTMLJePopoverElement;
    };
    interface HTMLJeRadioElement extends Components.JeRadio, HTMLStencilElement {
    }
    var HTMLJeRadioElement: {
        prototype: HTMLJeRadioElement;
        new (): HTMLJeRadioElement;
    };
    interface HTMLJeRadioButtonElement extends Components.JeRadioButton, HTMLStencilElement {
    }
    var HTMLJeRadioButtonElement: {
        prototype: HTMLJeRadioButtonElement;
        new (): HTMLJeRadioButtonElement;
    };
    interface HTMLJeRadioGroupElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeRadioGroupElement extends Components.JeRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRadioGroupElement: {
        prototype: HTMLJeRadioGroupElement;
        new (): HTMLJeRadioGroupElement;
    };
    interface HTMLJeRefresherElement extends Components.JeRefresher, HTMLStencilElement {
    }
    var HTMLJeRefresherElement: {
        prototype: HTMLJeRefresherElement;
        new (): HTMLJeRefresherElement;
    };
    interface HTMLJeSelectElement extends Components.JeSelect, HTMLStencilElement {
    }
    var HTMLJeSelectElement: {
        prototype: HTMLJeSelectElement;
        new (): HTMLJeSelectElement;
    };
    interface HTMLJeTabElement extends Components.JeTab, HTMLStencilElement {
    }
    var HTMLJeTabElement: {
        prototype: HTMLJeTabElement;
        new (): HTMLJeTabElement;
    };
    interface HTMLJeTabsElementEventMap {
        "valueChange": string | undefined;
    }
    interface HTMLJeTabsElement extends Components.JeTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTabsElement: {
        prototype: HTMLJeTabsElement;
        new (): HTMLJeTabsElement;
    };
    interface HTMLJeTextfieldElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeTextfieldElement extends Components.JeTextfield, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTextfieldElement: {
        prototype: HTMLJeTextfieldElement;
        new (): HTMLJeTextfieldElement;
    };
    interface HTMLJeToastContainerElement extends Components.JeToastContainer, HTMLStencilElement {
    }
    var HTMLJeToastContainerElement: {
        prototype: HTMLJeToastContainerElement;
        new (): HTMLJeToastContainerElement;
    };
    interface HTMLJeToggleElementEventMap {
        "toggled": boolean;
    }
    interface HTMLJeToggleElement extends Components.JeToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeToggleElement: {
        prototype: HTMLJeToggleElement;
        new (): HTMLJeToggleElement;
    };
    interface HTMLJeToolbarElement extends Components.JeToolbar, HTMLStencilElement {
    }
    var HTMLJeToolbarElement: {
        prototype: HTMLJeToolbarElement;
        new (): HTMLJeToolbarElement;
    };
    interface HTMLJeTooltipElement extends Components.JeTooltip, HTMLStencilElement {
    }
    var HTMLJeTooltipElement: {
        prototype: HTMLJeTooltipElement;
        new (): HTMLJeTooltipElement;
    };
    interface HTMLJeTreeElementEventMap {
        "valueChange": string | string[];
    }
    interface HTMLJeTreeElement extends Components.JeTree, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTreeElement: {
        prototype: HTMLJeTreeElement;
        new (): HTMLJeTreeElement;
    };
    interface HTMLJeWizardElementEventMap {
        "stepChange": number;
        "finish": void;
    }
    interface HTMLJeWizardElement extends Components.JeWizard, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeWizardElement: {
        prototype: HTMLJeWizardElement;
        new (): HTMLJeWizardElement;
    };
    interface HTMLElementTagNameMap {
        "je-accordion": HTMLJeAccordionElement;
        "je-action-sheet": HTMLJeActionSheetElement;
        "je-alert": HTMLJeAlertElement;
        "je-branch": HTMLJeBranchElement;
        "je-breadcrumb": HTMLJeBreadcrumbElement;
        "je-breadcrumbs": HTMLJeBreadcrumbsElement;
        "je-button": HTMLJeButtonElement;
        "je-button-group": HTMLJeButtonGroupElement;
        "je-card": HTMLJeCardElement;
        "je-checkbox": HTMLJeCheckboxElement;
        "je-color": HTMLJeColorElement;
        "je-column": HTMLJeColumnElement;
        "je-column-group": HTMLJeColumnGroupElement;
        "je-datepicker": HTMLJeDatepickerElement;
        "je-details": HTMLJeDetailsElement;
        "je-divider": HTMLJeDividerElement;
        "je-drawer": HTMLJeDrawerElement;
        "je-dropzone": HTMLJeDropzoneElement;
        "je-form": HTMLJeFormElement;
        "je-icon": HTMLJeIconElement;
        "je-icon-button": HTMLJeIconButtonElement;
        "je-infinite": HTMLJeInfiniteElement;
        "je-item": HTMLJeItemElement;
        "je-label": HTMLJeLabelElement;
        "je-link": HTMLJeLinkElement;
        "je-list": HTMLJeListElement;
        "je-loading": HTMLJeLoadingElement;
        "je-modal": HTMLJeModalElement;
        "je-nav": HTMLJeNavElement;
        "je-note": HTMLJeNoteElement;
        "je-option": HTMLJeOptionElement;
        "je-page": HTMLJePageElement;
        "je-pill": HTMLJePillElement;
        "je-placeholder": HTMLJePlaceholderElement;
        "je-popover": HTMLJePopoverElement;
        "je-radio": HTMLJeRadioElement;
        "je-radio-button": HTMLJeRadioButtonElement;
        "je-radio-group": HTMLJeRadioGroupElement;
        "je-refresher": HTMLJeRefresherElement;
        "je-select": HTMLJeSelectElement;
        "je-tab": HTMLJeTabElement;
        "je-tabs": HTMLJeTabsElement;
        "je-textfield": HTMLJeTextfieldElement;
        "je-toast-container": HTMLJeToastContainerElement;
        "je-toggle": HTMLJeToggleElement;
        "je-toolbar": HTMLJeToolbarElement;
        "je-tooltip": HTMLJeTooltipElement;
        "je-tree": HTMLJeTreeElement;
        "je-wizard": HTMLJeWizardElement;
    }
}
declare namespace LocalJSX {
    interface JeAccordion {
    }
    interface JeActionSheet {
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Maximum height (expanded fullscreen).
         */
        "maxPercent"?: number;
        /**
          * Intermediate height (mid state).
         */
        "midPercent"?: number;
        /**
          * Minimum height (collapsed state).
         */
        "minPercent"?: number;
        /**
          * Emits whenever the drawer has finished closing. Emits the role and optional data object passed to the hide() method.
         */
        "onDismiss"?: (event: JeActionSheetCustomEvent<OverlayData>) => void;
        /**
          * Emits whenever the drawer has opened. Does not emit any data
         */
        "onPresent"?: (event: JeActionSheetCustomEvent<any>) => void;
        /**
          * Opens and closes modal
         */
        "open"?: boolean;
    }
    interface JeAlert {
        "closable"?: boolean;
        "color"?: Color;
        "duration"?: number;
        "header"?: string;
        "icon"?: string;
        "message"?: string;
        "onDismiss"?: (event: JeAlertCustomEvent<OverlayData>) => void;
        "onPresent"?: (event: JeAlertCustomEvent<any>) => void;
        "open"?: boolean;
        "progress"?: boolean;
    }
    interface JeBranch {
        "indentation"?: boolean;
        "label"?: string;
        "open"?: boolean;
        "selected"?: boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        "itemsAfterCollapse"?: number;
        "itemsBeforeCollapse"?: number;
        "maxItems"?: number;
        "onExpandClick"?: (event: JeBreadcrumbsCustomEvent<any>) => void;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
         */
        "disabled"?: boolean;
        /**
          * Expands the button to the full width of it's container
         */
        "expand"?: boolean;
        /**
          * Button fill
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Shows a loading spinner and disables the button
         */
        "pending"?: boolean;
        /**
          * Button size
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * Shows the disabled state and prevents changes
         */
        "disabled"?: boolean;
        /**
          * If the checkbox should contain a 3rd indeterminate state
         */
        "indeterminate"?: boolean;
        /**
          * Whether or not the label should go before or after the checkbox
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the current value whenever it's state changes
         */
        "onValueChange"?: (event: JeCheckboxCustomEvent<boolean | undefined>) => void;
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
         */
        "required"?: boolean;
        /**
          * Renders the component as a on/off switch rather than a checkbox.
         */
        "switch"?: boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color1;
        /**
          * Color in dark mode
         */
        "dark"?: Color1;
        /**
          * Color in light mode
         */
        "light"?: Color1;
    }
    interface JeColumn {
        /**
          * The size of the column, in terms of how many columns it should take up out of the total available.
         */
        "size"?: string;
        /**
          * The size of the column for lg screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeLg"?: string;
        /**
          * The size of the column for md screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeMd"?: string;
        /**
          * The size of the column for sm screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeSm"?: string;
        /**
          * The size of the column for xl screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXl"?: string;
        /**
          * The size of the column for xs screens, in terms of how many columns it should take up out of the total available.
         */
        "sizeXs"?: string;
    }
    interface JeColumnGroup {
        /**
          * Alignment of the columns.
         */
        "align"?: 'start' | 'center' | 'end' | 'stretch' | 'baseline';
        /**
          * The number of columns the flex grid has.
         */
        "columns"?: number;
        /**
          * The gap between the columns.
         */
        "gap"?: '3xs' | '2xs' |'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl';
        /**
          * Justification of the columns.
         */
        "justify"?: 'start' | 'center' | 'end' | 'space-between' | 'space-around';
        /**
          * If the columns should wrap.
         */
        "wrap"?: boolean;
    }
    interface JeDatepicker {
        "includeSeconds"?: boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        "onValueChange"?: (event: JeDatepickerCustomEvent<number | undefined>) => void;
        "type"?: 'date' | 'datetime' | 'time';
        "value"?: number;
    }
    interface JeDetails {
        "iconSide"?: 'left' | 'right';
        "iconToggle"?: boolean;
        "onCollapse"?: (event: JeDetailsCustomEvent<any>) => void;
        "onExpand"?: (event: JeDetailsCustomEvent<any>) => void;
        "open"?: boolean;
        "summary"?: string;
    }
    interface JeDivider {
        "spacing"?: 'sm' | 'md' | 'lg' | 'none';
        "type"?: 'horizontal' | 'vertical';
    }
    interface JeDrawer {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropDismiss"?: boolean;
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Emits whenever the backdrop is clicked. Does not emit any data
         */
        "onBackdropClick"?: (event: JeDrawerCustomEvent<any>) => void;
        /**
          * Emits whenever the drawer has finished closing. Emits the role and optional data object passed to the hide() method.
         */
        "onDismiss"?: (event: JeDrawerCustomEvent<OverlayData>) => void;
        /**
          * Emits whenever the drawer has opened. Does not emit any data
         */
        "onPresent"?: (event: JeDrawerCustomEvent<any>) => void;
        /**
          * Opens and closes modal
         */
        "open"?: boolean;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side"?: 'left' | 'right';
    }
    interface JeDropzone {
        "onDataDrop"?: (event: JeDropzoneCustomEvent<DataTransfer>) => void;
    }
    interface JeForm {
        "onFormData"?: (event: JeFormCustomEvent<Record<string, any>>) => void;
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
         */
        "fill"?: boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
         */
        "size"?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
         */
        "weight"?: number;
    }
    interface JeIconButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
         */
        "disabled"?: boolean;
        /**
          * Button fill
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Name of icon
         */
        "icon"?: string;
        /**
          * Shows a loading spinner and disables the button
         */
        "pending"?: boolean;
        /**
          * Button size
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeInfinite {
        /**
          * This must be manually set to true/false to show/hide the intersecting content
         */
        "loading"?: boolean;
        /**
          * Emitted when the bottom of the scroll container is in the viewport
         */
        "onIntersect"?: (event: JeInfiniteCustomEvent<void>) => void;
        /**
          * Passed to observer api
         */
        "rootMargin"?: string;
        /**
          * Threshold passed to observer api
         */
        "threshold"?: number;
    }
    interface JeItem {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
         */
        "bold"?: boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
         */
        "underline"?: boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeModal {
        /**
          * Backdrop will close the modal on click when enabled
         */
        "backdropDismiss"?: boolean;
        /**
          * Optionally execute a promise before closing begins
         */
        "destroy"?: () => void | Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Emits whenever the backdrop is clicked. Does not emit any data
         */
        "onBackdropClick"?: (event: JeModalCustomEvent<any>) => void;
        /**
          * Emits whenever the modal has finished closing. Emits the role and optional data object passed to the hide() method.
         */
        "onDismiss"?: (event: JeModalCustomEvent<OverlayData>) => void;
        /**
          * Emits whenever the modal has opened. Does not emit any data
         */
        "onPresent"?: (event: JeModalCustomEvent<any>) => void;
        /**
          * Opens and closes modal
         */
        "open"?: boolean;
        /**
          * Whether or not the backdrop will be visible to the user
         */
        "showBackdrop"?: boolean;
        /**
          * Size of the modal
         */
        "size"?: 'sm' | 'md' | 'lg';
    }
    interface JeNav {
        "mode"?: 'top' | 'side';
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
    }
    interface JePage {
        /**
          * Changes certain aspects of the page layout. - Sticky will make the entire page scrollable, and the footer will not be visible when the page is overflowing - Flex will make the main element scrollable, and the footer will always be visible
         */
        "layout"?: 'sticky' | 'flex';
    }
    interface JePill {
        "button"?: boolean;
        "disabled"?: boolean;
        "outline"?: boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
         */
        "animated"?: boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
         */
        "arrow"?: boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
         */
        "arrowPadding"?: number;
        /**
          * Backdrop will dismiss the popover on click when enabled
         */
        "backdropDismiss"?: boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
         */
        "dismissOnClick"?: boolean;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
         */
        "matchWidth"?: boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY"?: number;
        /**
          * Emits when the popover is closed
         */
        "onDismiss"?: (event: JePopoverCustomEvent<OverlayData>) => void;
        /**
          * Emits when the popover is opened
         */
        "onPresent"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover has completed it's initial render
         */
        "onReady"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Opens/closes the popover
         */
        "open"?: boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
         */
        "positionStrategy"?: 'click' | 'element';
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
         */
        "triggerAction"?: 'click' | 'context-menu' | 'hover';
    }
    interface JeRadio {
        /**
          * Disables option and shows state
         */
        "disabled"?: boolean;
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value"?: any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
         */
        "selected"?: boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Label that shows above the controls
         */
        "label"?: string;
        /**
          * Emits the selected value whenever it changes
         */
        "onValueChange"?: (event: JeRadioGroupCustomEvent<any>) => void;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRefresher {
    }
    interface JeSelect {
    }
    interface JeTab {
        "active"?: boolean;
        "value"?: string;
    }
    interface JeTabs {
        "mode"?: 'mobile' | 'pill' | 'segment';
        "onValueChange"?: (event: JeTabsCustomEvent<string | undefined>) => void;
        "value"?: string;
    }
    interface JeTextfield {
        /**
          * Passed to native input
         */
        "autoCapitalize"?: string;
        /**
          * Passed to native input
         */
        "autoComplete"?: string;
        /**
          * Passed to native input
         */
        "autoCorrect"?: 'off' | 'on';
        /**
          * Passed to native input
         */
        "autoFocus"?: boolean;
        /**
          * Optional debounce of the didInput event
         */
        "debounce"?: number;
        /**
          * Renders input as disabled and prevents changes
         */
        "disabled"?: boolean;
        /**
          * Shows an error icon in the end slot when true. If a string is passed in, it will render the icon as a tooltip. Has no effect on form validation
         */
        "error"?: any;
        /**
          * Formatters functions that are applied as the user types
         */
        "format"?: FormatterFn;
        /**
          * Passed to native input
         */
        "inputMode"?: string;
        /**
          * Text above the control
         */
        "label"?: string;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
         */
        "multiline"?: boolean;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * Emits as the user types
         */
        "onValueChange"?: (event: JeTextfieldCustomEvent<any>) => void;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: string;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Shows a loading indicator in the end slot when true
         */
        "pending"?: boolean;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
         */
        "readonly"?: boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
         */
        "required"?: boolean;
        /**
          * Container size
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
         */
        "spellcheck"?: boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Shows a success icon in the end slot when true. Has no effect on form validation
         */
        "success"?: boolean;
        /**
          * Transforms the value before it is passed to the input (from) and after the input emits a new value (to).  There are built-in transformers for 'number', 'date', and 'datetime'.
         */
        "transform"?: InputTransformer | 'number' | 'date' | 'datetime';
        /**
          * Passed to native input
         */
        "type"?: string;
        /**
          * Validator functions for form participation
         */
        "validators"?: ValidationFn[];
        /**
          * Current value of the input
         */
        "value"?: any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToastContainer {
        "position"?: 'top' | 'bottom' | 'top-end' | 'top-start' | 'bottom-end' | 'bottom-start';
    }
    interface JeToggle {
        /**
          * Whether or not the toggle is active
         */
        "checked"?: boolean;
        /**
          * If the label should be placed at the start or end of the toggle
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the new value whenever toggle is clicked
         */
        "onToggled"?: (event: JeToggleCustomEvent<boolean>) => void;
    }
    interface JeToolbar {
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
         */
        "offsetY"?: number;
    }
    interface JeTree {
        "indentation"?: boolean;
        "onValueChange"?: (event: JeTreeCustomEvent<string | string[]>) => void;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeWizard {
        "onFinish"?: (event: JeWizardCustomEvent<void>) => void;
        "onStepChange"?: (event: JeWizardCustomEvent<number>) => void;
        "steps"?: { label: string, optional?: boolean }[];
    }
    interface IntrinsicElements {
        "je-accordion": JeAccordion;
        "je-action-sheet": JeActionSheet;
        "je-alert": JeAlert;
        "je-branch": JeBranch;
        "je-breadcrumb": JeBreadcrumb;
        "je-breadcrumbs": JeBreadcrumbs;
        "je-button": JeButton;
        "je-button-group": JeButtonGroup;
        "je-card": JeCard;
        "je-checkbox": JeCheckbox;
        "je-color": JeColor;
        "je-column": JeColumn;
        "je-column-group": JeColumnGroup;
        "je-datepicker": JeDatepicker;
        "je-details": JeDetails;
        "je-divider": JeDivider;
        "je-drawer": JeDrawer;
        "je-dropzone": JeDropzone;
        "je-form": JeForm;
        "je-icon": JeIcon;
        "je-icon-button": JeIconButton;
        "je-infinite": JeInfinite;
        "je-item": JeItem;
        "je-label": JeLabel;
        "je-link": JeLink;
        "je-list": JeList;
        "je-loading": JeLoading;
        "je-modal": JeModal;
        "je-nav": JeNav;
        "je-note": JeNote;
        "je-option": JeOption;
        "je-page": JePage;
        "je-pill": JePill;
        "je-placeholder": JePlaceholder;
        "je-popover": JePopover;
        "je-radio": JeRadio;
        "je-radio-button": JeRadioButton;
        "je-radio-group": JeRadioGroup;
        "je-refresher": JeRefresher;
        "je-select": JeSelect;
        "je-tab": JeTab;
        "je-tabs": JeTabs;
        "je-textfield": JeTextfield;
        "je-toast-container": JeToastContainer;
        "je-toggle": JeToggle;
        "je-toolbar": JeToolbar;
        "je-tooltip": JeTooltip;
        "je-tree": JeTree;
        "je-wizard": JeWizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "je-accordion": LocalJSX.JeAccordion & JSXBase.HTMLAttributes<HTMLJeAccordionElement>;
            "je-action-sheet": LocalJSX.JeActionSheet & JSXBase.HTMLAttributes<HTMLJeActionSheetElement>;
            "je-alert": LocalJSX.JeAlert & JSXBase.HTMLAttributes<HTMLJeAlertElement>;
            "je-branch": LocalJSX.JeBranch & JSXBase.HTMLAttributes<HTMLJeBranchElement>;
            "je-breadcrumb": LocalJSX.JeBreadcrumb & JSXBase.HTMLAttributes<HTMLJeBreadcrumbElement>;
            "je-breadcrumbs": LocalJSX.JeBreadcrumbs & JSXBase.HTMLAttributes<HTMLJeBreadcrumbsElement>;
            "je-button": LocalJSX.JeButton & JSXBase.HTMLAttributes<HTMLJeButtonElement>;
            "je-button-group": LocalJSX.JeButtonGroup & JSXBase.HTMLAttributes<HTMLJeButtonGroupElement>;
            "je-card": LocalJSX.JeCard & JSXBase.HTMLAttributes<HTMLJeCardElement>;
            "je-checkbox": LocalJSX.JeCheckbox & JSXBase.HTMLAttributes<HTMLJeCheckboxElement>;
            "je-color": LocalJSX.JeColor & JSXBase.HTMLAttributes<HTMLJeColorElement>;
            "je-column": LocalJSX.JeColumn & JSXBase.HTMLAttributes<HTMLJeColumnElement>;
            "je-column-group": LocalJSX.JeColumnGroup & JSXBase.HTMLAttributes<HTMLJeColumnGroupElement>;
            "je-datepicker": LocalJSX.JeDatepicker & JSXBase.HTMLAttributes<HTMLJeDatepickerElement>;
            "je-details": LocalJSX.JeDetails & JSXBase.HTMLAttributes<HTMLJeDetailsElement>;
            "je-divider": LocalJSX.JeDivider & JSXBase.HTMLAttributes<HTMLJeDividerElement>;
            "je-drawer": LocalJSX.JeDrawer & JSXBase.HTMLAttributes<HTMLJeDrawerElement>;
            "je-dropzone": LocalJSX.JeDropzone & JSXBase.HTMLAttributes<HTMLJeDropzoneElement>;
            "je-form": LocalJSX.JeForm & JSXBase.HTMLAttributes<HTMLJeFormElement>;
            "je-icon": LocalJSX.JeIcon & JSXBase.HTMLAttributes<HTMLJeIconElement>;
            "je-icon-button": LocalJSX.JeIconButton & JSXBase.HTMLAttributes<HTMLJeIconButtonElement>;
            "je-infinite": LocalJSX.JeInfinite & JSXBase.HTMLAttributes<HTMLJeInfiniteElement>;
            "je-item": LocalJSX.JeItem & JSXBase.HTMLAttributes<HTMLJeItemElement>;
            "je-label": LocalJSX.JeLabel & JSXBase.HTMLAttributes<HTMLJeLabelElement>;
            "je-link": LocalJSX.JeLink & JSXBase.HTMLAttributes<HTMLJeLinkElement>;
            "je-list": LocalJSX.JeList & JSXBase.HTMLAttributes<HTMLJeListElement>;
            "je-loading": LocalJSX.JeLoading & JSXBase.HTMLAttributes<HTMLJeLoadingElement>;
            "je-modal": LocalJSX.JeModal & JSXBase.HTMLAttributes<HTMLJeModalElement>;
            "je-nav": LocalJSX.JeNav & JSXBase.HTMLAttributes<HTMLJeNavElement>;
            "je-note": LocalJSX.JeNote & JSXBase.HTMLAttributes<HTMLJeNoteElement>;
            "je-option": LocalJSX.JeOption & JSXBase.HTMLAttributes<HTMLJeOptionElement>;
            "je-page": LocalJSX.JePage & JSXBase.HTMLAttributes<HTMLJePageElement>;
            "je-pill": LocalJSX.JePill & JSXBase.HTMLAttributes<HTMLJePillElement>;
            "je-placeholder": LocalJSX.JePlaceholder & JSXBase.HTMLAttributes<HTMLJePlaceholderElement>;
            "je-popover": LocalJSX.JePopover & JSXBase.HTMLAttributes<HTMLJePopoverElement>;
            "je-radio": LocalJSX.JeRadio & JSXBase.HTMLAttributes<HTMLJeRadioElement>;
            "je-radio-button": LocalJSX.JeRadioButton & JSXBase.HTMLAttributes<HTMLJeRadioButtonElement>;
            "je-radio-group": LocalJSX.JeRadioGroup & JSXBase.HTMLAttributes<HTMLJeRadioGroupElement>;
            "je-refresher": LocalJSX.JeRefresher & JSXBase.HTMLAttributes<HTMLJeRefresherElement>;
            "je-select": LocalJSX.JeSelect & JSXBase.HTMLAttributes<HTMLJeSelectElement>;
            "je-tab": LocalJSX.JeTab & JSXBase.HTMLAttributes<HTMLJeTabElement>;
            "je-tabs": LocalJSX.JeTabs & JSXBase.HTMLAttributes<HTMLJeTabsElement>;
            "je-textfield": LocalJSX.JeTextfield & JSXBase.HTMLAttributes<HTMLJeTextfieldElement>;
            "je-toast-container": LocalJSX.JeToastContainer & JSXBase.HTMLAttributes<HTMLJeToastContainerElement>;
            "je-toggle": LocalJSX.JeToggle & JSXBase.HTMLAttributes<HTMLJeToggleElement>;
            "je-toolbar": LocalJSX.JeToolbar & JSXBase.HTMLAttributes<HTMLJeToolbarElement>;
            "je-tooltip": LocalJSX.JeTooltip & JSXBase.HTMLAttributes<HTMLJeTooltipElement>;
            "je-tree": LocalJSX.JeTree & JSXBase.HTMLAttributes<HTMLJeTreeElement>;
            "je-wizard": LocalJSX.JeWizard & JSXBase.HTMLAttributes<HTMLJeWizardElement>;
        }
    }
}
