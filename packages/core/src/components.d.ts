/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { Color } from "./utils/color";
import { OverlayData } from "./components/je-overlay/je-overlay";
import { Placement } from "@floating-ui/dom";
import { EditorChangeEvent } from "./components/je-rich-text/je-rich-text";
import { FormatterFn, InputTransformer, ValidationFn } from "./components/je-textfield/je-textfield";
export { Color } from "./utils/color";
export { OverlayData } from "./components/je-overlay/je-overlay";
export { Placement } from "@floating-ui/dom";
export { EditorChangeEvent } from "./components/je-rich-text/je-rich-text";
export { FormatterFn, InputTransformer, ValidationFn } from "./components/je-textfield/je-textfield";
export namespace Components {
    /**
     * Accordions are wrappers for [JeDetails](../je-details). When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface JeAccordion {
    }
    interface JeAlert {
        /**
          * @default false
         */
        "closable": boolean;
        /**
          * @default 'primary'
         */
        "color": Color;
        "didDismiss": () => Promise<unknown>;
        /**
          * @default 0
         */
        "duration": number;
        "header"?: string;
        "hide": (role?: string, data?: any) => Promise<void>;
        "icon"?: string;
        "message"?: string;
        /**
          * @default false
         */
        "open": boolean;
        /**
          * @default false
         */
        "progress": boolean;
        "show": () => Promise<void>;
    }
    interface JeBranch {
        "href"?: string;
        /**
          * @default false
         */
        "indentation": boolean;
        "isLeaf": () => Promise<boolean>;
        "label"?: string;
        /**
          * @default false
         */
        "open": boolean;
        /**
          * @default false
         */
        "selected": boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        /**
          * @default 1
         */
        "itemsAfterCollapse": number;
        /**
          * @default 1
         */
        "itemsBeforeCollapse": number;
        "maxItems"?: number;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
          * @default false
         */
        "disabled": boolean;
        /**
          * Expands the button to the full width of it's container
          * @default false
         */
        "expand": boolean;
        /**
          * Button fill
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Can set form id to participate in forms. Use this if you need to place submit/reset button outside the form element
         */
        "form"?: string;
        /**
          * Shows a loading spinner and disables the button
          * @default false
         */
        "pending": boolean;
        /**
          * Button size
          * @default 'md'
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCalendar {
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * If the checkbox should contain a 3rd indeterminate state
          * @default false
         */
        "indeterminate": boolean;
        /**
          * Whether or not the label should go before or after the checkbox
          * @default 'end'
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
          * @default false
         */
        "required": boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color;
        /**
          * Color in dark mode
         */
        "dark"?: Color;
        /**
          * Color in light mode
         */
        "light"?: Color;
    }
    interface JeComp {
    }
    interface JeControl {
    }
    interface JeDatepicker {
        /**
          * @default false
         */
        "includeSeconds": boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        /**
          * @default 'datetime'
         */
        "type": 'date' | 'datetime' | 'time';
        "value"?: number;
    }
    interface JeDaw {
    }
    interface JeDetails {
        /**
          * @default 'right'
         */
        "iconSide": 'left' | 'right';
        /**
          * @default false
         */
        "iconToggle": boolean;
        /**
          * @default false
         */
        "open": boolean;
        "summary"?: string;
    }
    interface JeDiscardForm {
    }
    interface JeDivider {
        /**
          * @default 'md'
         */
        "spacing": 'sm' | 'md' | 'lg' | 'none';
        /**
          * @default 'horizontal'
         */
        "type": 'horizontal' | 'vertical';
    }
    interface JeDropzone {
    }
    interface JeEq {
    }
    interface JeForm {
    }
    interface JeGrid {
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
          * @default false
         */
        "fill": boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
          * @default 'md'
         */
        "size": 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
          * @default 400
         */
        "weight": number;
    }
    interface JeItem {
    }
    interface JeKnob {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
          * @default false
         */
        "bold": boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
          * @default true
         */
        "underline": boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeMidi {
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "value": any;
    }
    interface JeOverlay {
        /**
          * Backdrop will close the modal on click when enabled
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * Optionally execute a promise after closing completes
         */
        "destroy"?: () => void | Promise<void>;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Opens and closes modal
          * @default false
         */
        "open": boolean;
        "show": () => Promise<void>;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side"?: 'left' | 'right' | 'bottom' | 'top';
        /**
          * Size of the overlay
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
    }
    interface JeOverlayContent {
        /**
          * @default true
         */
        "closable": boolean;
        "label"?: string;
    }
    interface JePage {
    }
    interface JePill {
        /**
          * @default false
         */
        "outline": boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
          * @default true
         */
        "animated": boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
          * @default true
         */
        "arrow": boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
          * @default 6
         */
        "arrowPadding": number;
        /**
          * Backdrop will dismiss the popover on click when enabled
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
          * @default false
         */
        "dismissOnClick": boolean;
        "hide": (role?: string, data?: any) => Promise<void>;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
          * @default false
         */
        "matchWidth": boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY": number;
        /**
          * Opens/closes the popover
          * @default false
         */
        "open": boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
          * @default 'element'
         */
        "positionStrategy": 'click' | 'element';
        "show": () => Promise<void>;
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
          * @default 'click'
         */
        "triggerAction": 'click' | 'context-menu' | 'hover';
    }
    interface JeRadio {
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value": any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
          * @default false
         */
        "selected": boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Disables the controls
          * @default false
         */
        "disabled": boolean;
        /**
          * Label that shows above the control
         */
        "label"?: string;
        /**
          * Additional info that shows below the control
         */
        "note"?: string;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRange {
    }
    interface JeReorderItem {
    }
    interface JeReorderList {
    }
    interface JeRichText {
        "clear": () => Promise<void>;
        /**
          * @default false
         */
        "disabled": boolean;
        "getContent": () => Promise<string>;
        "getText": () => Promise<string>;
        /**
          * @default '500px'
         */
        "maxHeight": string;
        /**
          * @default '200px'
         */
        "minHeight": string;
        /**
          * @default 'Start typing...'
         */
        "placeholder": string;
        /**
          * @default false
         */
        "readonly": boolean;
        "setContent": (html: string) => Promise<void>;
        /**
          * @default true
         */
        "showWordCount": boolean;
        /**
          * @default ''
         */
        "value": string;
    }
    interface JeSelect {
        /**
          * @default false
         */
        "disabled": boolean;
        "label"?: string;
        /**
          * @default false
         */
        "multiple": boolean;
        "note"?: string;
        "options"?: { value: any, label: string }[];
        "originalValue": any;
        "placeholder"?: string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default 'md'
         */
        "size": 'md' | 'lg' | 'sm';
        "value": any;
    }
    interface JeSplitPanel {
    }
    interface JeSplitView {
    }
    interface JeStack {
    }
    interface JeSynth {
    }
    interface JeTab {
        /**
          * @default false
         */
        "active": boolean;
        "value"?: string;
    }
    interface JeTabs {
        /**
          * @default 'segment'
         */
        "mode": 'mobile' | 'pill' | 'segment';
        "value"?: string;
    }
    interface JeTextfield {
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoCapitalize": string;
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoComplete": string;
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoCorrect": 'off' | 'on';
        /**
          * Passed to native input
         */
        "autoFocus"?: boolean;
        /**
          * Optional debounce of the didInput event
          * @default 0
         */
        "debounce": number;
        /**
          * Renders input as disabled and prevents changes
          * @default false
         */
        "disabled": boolean;
        /**
          * Shows an error icon in the end slot when true. If a string is passed in, it will render the icon as a tooltip. Has no effect on form validation
         */
        "error": any;
        /**
          * Formatters functions that are applied as the user types
         */
        "format"?: FormatterFn;
        "getErrors": () => Promise<{ requiredError: boolean; minLengthError: boolean; maxLengthError: boolean; patternError: boolean; customErrors: string[]; hasError: boolean; }>;
        "getInputElement": () => Promise<HTMLInputElement | HTMLTextAreaElement>;
        /**
          * Passed to native input
         */
        "inputMode": string;
        "isTouched": () => Promise<boolean>;
        /**
          * Text above the control
         */
        "label"?: string;
        "markAsTouched": () => Promise<void>;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
          * @default false
         */
        "multiline": boolean;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: string;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Shows a loading indicator in the end slot when true
          * @default false
         */
        "pending": boolean;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
          * @default false
         */
        "readonly": boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
          * @default false
         */
        "required": boolean;
        /**
          * Container size
          * @default 'md'
         */
        "size": 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
          * @default false
         */
        "spellcheck": boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Shows a success icon in the end slot when true. Has no effect on form validation
          * @default false
         */
        "success": boolean;
        /**
          * Whether to suppress the default behavior of the input event
          * @default false
         */
        "suppressDefaultBehavior": boolean;
        /**
          * Transforms the value before it is passed to the input (from) and after the input emits a new value (to).  There are built-in transformers for 'number', 'date', and 'datetime'.
         */
        "transform"?: InputTransformer | 'number' | 'date' | 'datetime';
        /**
          * Passed to native input
          * @default 'text'
         */
        "type": string;
        /**
          * Validator functions for form participation
         */
        "validators"?: ValidationFn[];
        /**
          * Current value of the input
         */
        "value": any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToggle {
        /**
          * If the label should be placed at the start or end of the toggle
          * @default 'end'
         */
        "labelPlacement": 'start' | 'end';
        /**
          * Original value form will reset to
         */
        "originalValue": boolean;
        /**
          * Whether or not the toggle is active
          * @default false
         */
        "value": boolean;
    }
    interface JeToolbar {
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX": number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY": number;
    }
    interface JeTree {
        /**
          * @default false
         */
        "indentation": boolean;
        /**
          * @default 'leaf'
         */
        "selection": 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeWizard {
        "canSkip": () => Promise<boolean>;
        "next": () => Promise<void>;
        "previous": () => Promise<void>;
        "reset": () => Promise<void>;
        "skip": () => Promise<void>;
        /**
          * @default []
         */
        "steps": { label: string, optional?: boolean }[];
    }
}
export interface JeAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeAlertElement;
}
export interface JeBreadcrumbsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeBreadcrumbsElement;
}
export interface JeCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeCheckboxElement;
}
export interface JeDatepickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDatepickerElement;
}
export interface JeDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDetailsElement;
}
export interface JeDropzoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeDropzoneElement;
}
export interface JeFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeFormElement;
}
export interface JeOverlayCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeOverlayElement;
}
export interface JePopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJePopoverElement;
}
export interface JeRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRadioGroupElement;
}
export interface JeRichTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeRichTextElement;
}
export interface JeSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeSelectElement;
}
export interface JeTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTabsElement;
}
export interface JeTextfieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTextfieldElement;
}
export interface JeToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeToggleElement;
}
export interface JeTreeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeTreeElement;
}
export interface JeWizardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLJeWizardElement;
}
declare global {
    /**
     * Accordions are wrappers for [JeDetails](../je-details). When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface HTMLJeAccordionElement extends Components.JeAccordion, HTMLStencilElement {
    }
    var HTMLJeAccordionElement: {
        prototype: HTMLJeAccordionElement;
        new (): HTMLJeAccordionElement;
    };
    interface HTMLJeAlertElementEventMap {
        "present": any;
        "dismiss": any;
    }
    interface HTMLJeAlertElement extends Components.JeAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeAlertElementEventMap>(type: K, listener: (this: HTMLJeAlertElement, ev: JeAlertCustomEvent<HTMLJeAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeAlertElement: {
        prototype: HTMLJeAlertElement;
        new (): HTMLJeAlertElement;
    };
    interface HTMLJeBranchElement extends Components.JeBranch, HTMLStencilElement {
    }
    var HTMLJeBranchElement: {
        prototype: HTMLJeBranchElement;
        new (): HTMLJeBranchElement;
    };
    interface HTMLJeBreadcrumbElement extends Components.JeBreadcrumb, HTMLStencilElement {
    }
    var HTMLJeBreadcrumbElement: {
        prototype: HTMLJeBreadcrumbElement;
        new (): HTMLJeBreadcrumbElement;
    };
    interface HTMLJeBreadcrumbsElementEventMap {
        "expandClick": any;
    }
    interface HTMLJeBreadcrumbsElement extends Components.JeBreadcrumbs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeBreadcrumbsElementEventMap>(type: K, listener: (this: HTMLJeBreadcrumbsElement, ev: JeBreadcrumbsCustomEvent<HTMLJeBreadcrumbsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeBreadcrumbsElement: {
        prototype: HTMLJeBreadcrumbsElement;
        new (): HTMLJeBreadcrumbsElement;
    };
    interface HTMLJeButtonElement extends Components.JeButton, HTMLStencilElement {
    }
    var HTMLJeButtonElement: {
        prototype: HTMLJeButtonElement;
        new (): HTMLJeButtonElement;
    };
    interface HTMLJeButtonGroupElement extends Components.JeButtonGroup, HTMLStencilElement {
    }
    var HTMLJeButtonGroupElement: {
        prototype: HTMLJeButtonGroupElement;
        new (): HTMLJeButtonGroupElement;
    };
    interface HTMLJeCalendarElement extends Components.JeCalendar, HTMLStencilElement {
    }
    var HTMLJeCalendarElement: {
        prototype: HTMLJeCalendarElement;
        new (): HTMLJeCalendarElement;
    };
    interface HTMLJeCardElement extends Components.JeCard, HTMLStencilElement {
    }
    var HTMLJeCardElement: {
        prototype: HTMLJeCardElement;
        new (): HTMLJeCardElement;
    };
    interface HTMLJeCheckboxElementEventMap {
        "valueChange": boolean | undefined;
    }
    interface HTMLJeCheckboxElement extends Components.JeCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeCheckboxElementEventMap>(type: K, listener: (this: HTMLJeCheckboxElement, ev: JeCheckboxCustomEvent<HTMLJeCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeCheckboxElement: {
        prototype: HTMLJeCheckboxElement;
        new (): HTMLJeCheckboxElement;
    };
    interface HTMLJeColorElement extends Components.JeColor, HTMLStencilElement {
    }
    var HTMLJeColorElement: {
        prototype: HTMLJeColorElement;
        new (): HTMLJeColorElement;
    };
    interface HTMLJeCompElement extends Components.JeComp, HTMLStencilElement {
    }
    var HTMLJeCompElement: {
        prototype: HTMLJeCompElement;
        new (): HTMLJeCompElement;
    };
    interface HTMLJeControlElement extends Components.JeControl, HTMLStencilElement {
    }
    var HTMLJeControlElement: {
        prototype: HTMLJeControlElement;
        new (): HTMLJeControlElement;
    };
    interface HTMLJeDatepickerElementEventMap {
        "valueChange": number;
    }
    interface HTMLJeDatepickerElement extends Components.JeDatepicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDatepickerElementEventMap>(type: K, listener: (this: HTMLJeDatepickerElement, ev: JeDatepickerCustomEvent<HTMLJeDatepickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDatepickerElement: {
        prototype: HTMLJeDatepickerElement;
        new (): HTMLJeDatepickerElement;
    };
    interface HTMLJeDawElement extends Components.JeDaw, HTMLStencilElement {
    }
    var HTMLJeDawElement: {
        prototype: HTMLJeDawElement;
        new (): HTMLJeDawElement;
    };
    interface HTMLJeDetailsElementEventMap {
        "expand": any;
        "collapse": any;
    }
    interface HTMLJeDetailsElement extends Components.JeDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDetailsElementEventMap>(type: K, listener: (this: HTMLJeDetailsElement, ev: JeDetailsCustomEvent<HTMLJeDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDetailsElement: {
        prototype: HTMLJeDetailsElement;
        new (): HTMLJeDetailsElement;
    };
    interface HTMLJeDiscardFormElement extends Components.JeDiscardForm, HTMLStencilElement {
    }
    var HTMLJeDiscardFormElement: {
        prototype: HTMLJeDiscardFormElement;
        new (): HTMLJeDiscardFormElement;
    };
    interface HTMLJeDividerElement extends Components.JeDivider, HTMLStencilElement {
    }
    var HTMLJeDividerElement: {
        prototype: HTMLJeDividerElement;
        new (): HTMLJeDividerElement;
    };
    interface HTMLJeDropzoneElementEventMap {
        "dataDrop": DataTransfer;
    }
    interface HTMLJeDropzoneElement extends Components.JeDropzone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeDropzoneElementEventMap>(type: K, listener: (this: HTMLJeDropzoneElement, ev: JeDropzoneCustomEvent<HTMLJeDropzoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeDropzoneElement: {
        prototype: HTMLJeDropzoneElement;
        new (): HTMLJeDropzoneElement;
    };
    interface HTMLJeEqElement extends Components.JeEq, HTMLStencilElement {
    }
    var HTMLJeEqElement: {
        prototype: HTMLJeEqElement;
        new (): HTMLJeEqElement;
    };
    interface HTMLJeFormElementEventMap {
        "formData": Record<string, any>;
    }
    interface HTMLJeFormElement extends Components.JeForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeFormElementEventMap>(type: K, listener: (this: HTMLJeFormElement, ev: JeFormCustomEvent<HTMLJeFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeFormElement: {
        prototype: HTMLJeFormElement;
        new (): HTMLJeFormElement;
    };
    interface HTMLJeGridElement extends Components.JeGrid, HTMLStencilElement {
    }
    var HTMLJeGridElement: {
        prototype: HTMLJeGridElement;
        new (): HTMLJeGridElement;
    };
    interface HTMLJeIconElement extends Components.JeIcon, HTMLStencilElement {
    }
    var HTMLJeIconElement: {
        prototype: HTMLJeIconElement;
        new (): HTMLJeIconElement;
    };
    interface HTMLJeItemElement extends Components.JeItem, HTMLStencilElement {
    }
    var HTMLJeItemElement: {
        prototype: HTMLJeItemElement;
        new (): HTMLJeItemElement;
    };
    interface HTMLJeKnobElement extends Components.JeKnob, HTMLStencilElement {
    }
    var HTMLJeKnobElement: {
        prototype: HTMLJeKnobElement;
        new (): HTMLJeKnobElement;
    };
    interface HTMLJeLabelElement extends Components.JeLabel, HTMLStencilElement {
    }
    var HTMLJeLabelElement: {
        prototype: HTMLJeLabelElement;
        new (): HTMLJeLabelElement;
    };
    interface HTMLJeLinkElement extends Components.JeLink, HTMLStencilElement {
    }
    var HTMLJeLinkElement: {
        prototype: HTMLJeLinkElement;
        new (): HTMLJeLinkElement;
    };
    interface HTMLJeListElement extends Components.JeList, HTMLStencilElement {
    }
    var HTMLJeListElement: {
        prototype: HTMLJeListElement;
        new (): HTMLJeListElement;
    };
    interface HTMLJeLoadingElement extends Components.JeLoading, HTMLStencilElement {
    }
    var HTMLJeLoadingElement: {
        prototype: HTMLJeLoadingElement;
        new (): HTMLJeLoadingElement;
    };
    interface HTMLJeMidiElement extends Components.JeMidi, HTMLStencilElement {
    }
    var HTMLJeMidiElement: {
        prototype: HTMLJeMidiElement;
        new (): HTMLJeMidiElement;
    };
    interface HTMLJeNoteElement extends Components.JeNote, HTMLStencilElement {
    }
    var HTMLJeNoteElement: {
        prototype: HTMLJeNoteElement;
        new (): HTMLJeNoteElement;
    };
    interface HTMLJeOptionElement extends Components.JeOption, HTMLStencilElement {
    }
    var HTMLJeOptionElement: {
        prototype: HTMLJeOptionElement;
        new (): HTMLJeOptionElement;
    };
    interface HTMLJeOverlayElementEventMap {
        "present": any;
        "dismiss": OverlayData;
    }
    interface HTMLJeOverlayElement extends Components.JeOverlay, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeOverlayElementEventMap>(type: K, listener: (this: HTMLJeOverlayElement, ev: JeOverlayCustomEvent<HTMLJeOverlayElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeOverlayElementEventMap>(type: K, listener: (this: HTMLJeOverlayElement, ev: JeOverlayCustomEvent<HTMLJeOverlayElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeOverlayElement: {
        prototype: HTMLJeOverlayElement;
        new (): HTMLJeOverlayElement;
    };
    interface HTMLJeOverlayContentElement extends Components.JeOverlayContent, HTMLStencilElement {
    }
    var HTMLJeOverlayContentElement: {
        prototype: HTMLJeOverlayContentElement;
        new (): HTMLJeOverlayContentElement;
    };
    interface HTMLJePageElement extends Components.JePage, HTMLStencilElement {
    }
    var HTMLJePageElement: {
        prototype: HTMLJePageElement;
        new (): HTMLJePageElement;
    };
    interface HTMLJePillElement extends Components.JePill, HTMLStencilElement {
    }
    var HTMLJePillElement: {
        prototype: HTMLJePillElement;
        new (): HTMLJePillElement;
    };
    interface HTMLJePlaceholderElement extends Components.JePlaceholder, HTMLStencilElement {
    }
    var HTMLJePlaceholderElement: {
        prototype: HTMLJePlaceholderElement;
        new (): HTMLJePlaceholderElement;
    };
    interface HTMLJePopoverElementEventMap {
        "willPresent": any;
        "present": any;
        "dismiss": any;
        "willDismiss": any;
        "ready": any;
    }
    interface HTMLJePopoverElement extends Components.JePopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJePopoverElementEventMap>(type: K, listener: (this: HTMLJePopoverElement, ev: JePopoverCustomEvent<HTMLJePopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJePopoverElement: {
        prototype: HTMLJePopoverElement;
        new (): HTMLJePopoverElement;
    };
    interface HTMLJeRadioElement extends Components.JeRadio, HTMLStencilElement {
    }
    var HTMLJeRadioElement: {
        prototype: HTMLJeRadioElement;
        new (): HTMLJeRadioElement;
    };
    interface HTMLJeRadioButtonElement extends Components.JeRadioButton, HTMLStencilElement {
    }
    var HTMLJeRadioButtonElement: {
        prototype: HTMLJeRadioButtonElement;
        new (): HTMLJeRadioButtonElement;
    };
    interface HTMLJeRadioGroupElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeRadioGroupElement extends Components.JeRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRadioGroupElementEventMap>(type: K, listener: (this: HTMLJeRadioGroupElement, ev: JeRadioGroupCustomEvent<HTMLJeRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRadioGroupElement: {
        prototype: HTMLJeRadioGroupElement;
        new (): HTMLJeRadioGroupElement;
    };
    interface HTMLJeRangeElement extends Components.JeRange, HTMLStencilElement {
    }
    var HTMLJeRangeElement: {
        prototype: HTMLJeRangeElement;
        new (): HTMLJeRangeElement;
    };
    interface HTMLJeReorderItemElement extends Components.JeReorderItem, HTMLStencilElement {
    }
    var HTMLJeReorderItemElement: {
        prototype: HTMLJeReorderItemElement;
        new (): HTMLJeReorderItemElement;
    };
    interface HTMLJeReorderListElement extends Components.JeReorderList, HTMLStencilElement {
    }
    var HTMLJeReorderListElement: {
        prototype: HTMLJeReorderListElement;
        new (): HTMLJeReorderListElement;
    };
    interface HTMLJeRichTextElementEventMap {
        "editorChange": EditorChangeEvent;
        "editorFocus": FocusEvent;
        "editorBlur": FocusEvent;
    }
    interface HTMLJeRichTextElement extends Components.JeRichText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeRichTextElementEventMap>(type: K, listener: (this: HTMLJeRichTextElement, ev: JeRichTextCustomEvent<HTMLJeRichTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeRichTextElementEventMap>(type: K, listener: (this: HTMLJeRichTextElement, ev: JeRichTextCustomEvent<HTMLJeRichTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeRichTextElement: {
        prototype: HTMLJeRichTextElement;
        new (): HTMLJeRichTextElement;
    };
    interface HTMLJeSelectElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeSelectElement extends Components.JeSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeSelectElementEventMap>(type: K, listener: (this: HTMLJeSelectElement, ev: JeSelectCustomEvent<HTMLJeSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeSelectElementEventMap>(type: K, listener: (this: HTMLJeSelectElement, ev: JeSelectCustomEvent<HTMLJeSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeSelectElement: {
        prototype: HTMLJeSelectElement;
        new (): HTMLJeSelectElement;
    };
    interface HTMLJeSplitPanelElement extends Components.JeSplitPanel, HTMLStencilElement {
    }
    var HTMLJeSplitPanelElement: {
        prototype: HTMLJeSplitPanelElement;
        new (): HTMLJeSplitPanelElement;
    };
    interface HTMLJeSplitViewElement extends Components.JeSplitView, HTMLStencilElement {
    }
    var HTMLJeSplitViewElement: {
        prototype: HTMLJeSplitViewElement;
        new (): HTMLJeSplitViewElement;
    };
    interface HTMLJeStackElement extends Components.JeStack, HTMLStencilElement {
    }
    var HTMLJeStackElement: {
        prototype: HTMLJeStackElement;
        new (): HTMLJeStackElement;
    };
    interface HTMLJeSynthElement extends Components.JeSynth, HTMLStencilElement {
    }
    var HTMLJeSynthElement: {
        prototype: HTMLJeSynthElement;
        new (): HTMLJeSynthElement;
    };
    interface HTMLJeTabElement extends Components.JeTab, HTMLStencilElement {
    }
    var HTMLJeTabElement: {
        prototype: HTMLJeTabElement;
        new (): HTMLJeTabElement;
    };
    interface HTMLJeTabsElementEventMap {
        "valueChange": string | undefined;
    }
    interface HTMLJeTabsElement extends Components.JeTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTabsElementEventMap>(type: K, listener: (this: HTMLJeTabsElement, ev: JeTabsCustomEvent<HTMLJeTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTabsElement: {
        prototype: HTMLJeTabsElement;
        new (): HTMLJeTabsElement;
    };
    interface HTMLJeTextfieldElementEventMap {
        "valueChange": any;
    }
    interface HTMLJeTextfieldElement extends Components.JeTextfield, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTextfieldElementEventMap>(type: K, listener: (this: HTMLJeTextfieldElement, ev: JeTextfieldCustomEvent<HTMLJeTextfieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTextfieldElement: {
        prototype: HTMLJeTextfieldElement;
        new (): HTMLJeTextfieldElement;
    };
    interface HTMLJeToggleElementEventMap {
        "valueChange": boolean;
    }
    interface HTMLJeToggleElement extends Components.JeToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeToggleElementEventMap>(type: K, listener: (this: HTMLJeToggleElement, ev: JeToggleCustomEvent<HTMLJeToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeToggleElement: {
        prototype: HTMLJeToggleElement;
        new (): HTMLJeToggleElement;
    };
    interface HTMLJeToolbarElement extends Components.JeToolbar, HTMLStencilElement {
    }
    var HTMLJeToolbarElement: {
        prototype: HTMLJeToolbarElement;
        new (): HTMLJeToolbarElement;
    };
    interface HTMLJeTooltipElement extends Components.JeTooltip, HTMLStencilElement {
    }
    var HTMLJeTooltipElement: {
        prototype: HTMLJeTooltipElement;
        new (): HTMLJeTooltipElement;
    };
    interface HTMLJeTreeElementEventMap {
        "valueChange": string | string[];
    }
    interface HTMLJeTreeElement extends Components.JeTree, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeTreeElementEventMap>(type: K, listener: (this: HTMLJeTreeElement, ev: JeTreeCustomEvent<HTMLJeTreeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeTreeElement: {
        prototype: HTMLJeTreeElement;
        new (): HTMLJeTreeElement;
    };
    interface HTMLJeWizardElementEventMap {
        "stepChange": number;
        "finish": void;
    }
    interface HTMLJeWizardElement extends Components.JeWizard, HTMLStencilElement {
        addEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLJeWizardElementEventMap>(type: K, listener: (this: HTMLJeWizardElement, ev: JeWizardCustomEvent<HTMLJeWizardElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLJeWizardElement: {
        prototype: HTMLJeWizardElement;
        new (): HTMLJeWizardElement;
    };
    interface HTMLElementTagNameMap {
        "je-accordion": HTMLJeAccordionElement;
        "je-alert": HTMLJeAlertElement;
        "je-branch": HTMLJeBranchElement;
        "je-breadcrumb": HTMLJeBreadcrumbElement;
        "je-breadcrumbs": HTMLJeBreadcrumbsElement;
        "je-button": HTMLJeButtonElement;
        "je-button-group": HTMLJeButtonGroupElement;
        "je-calendar": HTMLJeCalendarElement;
        "je-card": HTMLJeCardElement;
        "je-checkbox": HTMLJeCheckboxElement;
        "je-color": HTMLJeColorElement;
        "je-comp": HTMLJeCompElement;
        "je-control": HTMLJeControlElement;
        "je-datepicker": HTMLJeDatepickerElement;
        "je-daw": HTMLJeDawElement;
        "je-details": HTMLJeDetailsElement;
        "je-discard-form": HTMLJeDiscardFormElement;
        "je-divider": HTMLJeDividerElement;
        "je-dropzone": HTMLJeDropzoneElement;
        "je-eq": HTMLJeEqElement;
        "je-form": HTMLJeFormElement;
        "je-grid": HTMLJeGridElement;
        "je-icon": HTMLJeIconElement;
        "je-item": HTMLJeItemElement;
        "je-knob": HTMLJeKnobElement;
        "je-label": HTMLJeLabelElement;
        "je-link": HTMLJeLinkElement;
        "je-list": HTMLJeListElement;
        "je-loading": HTMLJeLoadingElement;
        "je-midi": HTMLJeMidiElement;
        "je-note": HTMLJeNoteElement;
        "je-option": HTMLJeOptionElement;
        "je-overlay": HTMLJeOverlayElement;
        "je-overlay-content": HTMLJeOverlayContentElement;
        "je-page": HTMLJePageElement;
        "je-pill": HTMLJePillElement;
        "je-placeholder": HTMLJePlaceholderElement;
        "je-popover": HTMLJePopoverElement;
        "je-radio": HTMLJeRadioElement;
        "je-radio-button": HTMLJeRadioButtonElement;
        "je-radio-group": HTMLJeRadioGroupElement;
        "je-range": HTMLJeRangeElement;
        "je-reorder-item": HTMLJeReorderItemElement;
        "je-reorder-list": HTMLJeReorderListElement;
        "je-rich-text": HTMLJeRichTextElement;
        "je-select": HTMLJeSelectElement;
        "je-split-panel": HTMLJeSplitPanelElement;
        "je-split-view": HTMLJeSplitViewElement;
        "je-stack": HTMLJeStackElement;
        "je-synth": HTMLJeSynthElement;
        "je-tab": HTMLJeTabElement;
        "je-tabs": HTMLJeTabsElement;
        "je-textfield": HTMLJeTextfieldElement;
        "je-toggle": HTMLJeToggleElement;
        "je-toolbar": HTMLJeToolbarElement;
        "je-tooltip": HTMLJeTooltipElement;
        "je-tree": HTMLJeTreeElement;
        "je-wizard": HTMLJeWizardElement;
    }
}
declare namespace LocalJSX {
    /**
     * Accordions are wrappers for [JeDetails](../je-details). When an inner detail is opened, the others are automatically closed.
     * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
     */
    interface JeAccordion {
    }
    interface JeAlert {
        /**
          * @default false
         */
        "closable"?: boolean;
        /**
          * @default 'primary'
         */
        "color"?: Color;
        /**
          * @default 0
         */
        "duration"?: number;
        "header"?: string;
        "icon"?: string;
        "message"?: string;
        "onDismiss"?: (event: JeAlertCustomEvent<any>) => void;
        "onPresent"?: (event: JeAlertCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
        /**
          * @default false
         */
        "progress"?: boolean;
    }
    interface JeBranch {
        "href"?: string;
        /**
          * @default false
         */
        "indentation"?: boolean;
        "label"?: string;
        /**
          * @default false
         */
        "open"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean | null;
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string;
    }
    interface JeBreadcrumb {
    }
    interface JeBreadcrumbs {
        /**
          * @default 1
         */
        "itemsAfterCollapse"?: number;
        /**
          * @default 1
         */
        "itemsBeforeCollapse"?: number;
        "maxItems"?: number;
        "onExpandClick"?: (event: JeBreadcrumbsCustomEvent<any>) => void;
    }
    interface JeButton {
        /**
          * Predefined colors
         */
        "color"?: Color;
        /**
          * Disables button
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Expands the button to the full width of it's container
          * @default false
         */
        "expand"?: boolean;
        /**
          * Button fill
         */
        "fill"?: 'solid' | 'outline' | 'clear';
        /**
          * Can set form id to participate in forms. Use this if you need to place submit/reset button outside the form element
         */
        "form"?: string;
        /**
          * Shows a loading spinner and disables the button
          * @default false
         */
        "pending"?: boolean;
        /**
          * Button size
          * @default 'md'
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Can set to submit or reset to participate in forms
         */
        "type"?: 'submit' | 'reset';
    }
    interface JeButtonGroup {
    }
    interface JeCalendar {
    }
    interface JeCard {
        "button"?: boolean;
        "color"?: Color;
    }
    interface JeCheckbox {
        /**
          * By default, it will submit true or false depending on the checked state. Use this property to submit a custom value instead.
         */
        "data"?: string;
        /**
          * If the checkbox should contain a 3rd indeterminate state
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * Whether or not the label should go before or after the checkbox
          * @default 'end'
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the current value whenever it's state changes
         */
        "onValueChange"?: (event: JeCheckboxCustomEvent<boolean | undefined>) => void;
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Marks the control as required in the form. This will only affect indeterminate checkboxes.
          * @default false
         */
        "required"?: boolean;
        /**
          * Whether or not the checkbox is active
         */
        "value"?: boolean;
    }
    interface JeColor {
        /**
          * Fixed color
         */
        "color"?: Color;
        /**
          * Color in dark mode
         */
        "dark"?: Color;
        /**
          * Color in light mode
         */
        "light"?: Color;
    }
    interface JeComp {
    }
    interface JeControl {
    }
    interface JeDatepicker {
        /**
          * @default false
         */
        "includeSeconds"?: boolean;
        "isDateDisabled"?: (date: Date) => boolean;
        "max"?: number;
        "min"?: number;
        "onValueChange"?: (event: JeDatepickerCustomEvent<number>) => void;
        /**
          * @default 'datetime'
         */
        "type"?: 'date' | 'datetime' | 'time';
        "value"?: number;
    }
    interface JeDaw {
    }
    interface JeDetails {
        /**
          * @default 'right'
         */
        "iconSide"?: 'left' | 'right';
        /**
          * @default false
         */
        "iconToggle"?: boolean;
        "onCollapse"?: (event: JeDetailsCustomEvent<any>) => void;
        "onExpand"?: (event: JeDetailsCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
        "summary"?: string;
    }
    interface JeDiscardForm {
    }
    interface JeDivider {
        /**
          * @default 'md'
         */
        "spacing"?: 'sm' | 'md' | 'lg' | 'none';
        /**
          * @default 'horizontal'
         */
        "type"?: 'horizontal' | 'vertical';
    }
    interface JeDropzone {
        "onDataDrop"?: (event: JeDropzoneCustomEvent<DataTransfer>) => void;
    }
    interface JeEq {
    }
    interface JeForm {
        "onFormData"?: (event: JeFormCustomEvent<Record<string, any>>) => void;
    }
    interface JeGrid {
    }
    interface JeIcon {
        /**
          * Whether or not the icon should be filled
          * @default false
         */
        "fill"?: boolean;
        /**
          * Icon grade
         */
        "grade"?: 'high' | 'low';
        /**
          * Size of the icon
          * @default 'md'
         */
        "size"?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
        /**
          * Icon weight
          * @default 400
         */
        "weight"?: number;
    }
    interface JeItem {
    }
    interface JeKnob {
    }
    interface JeLabel {
        "required"?: boolean;
    }
    interface JeLink {
        /**
          * Makes text bold
          * @default false
         */
        "bold"?: boolean;
        /**
          * Passed to anchor
         */
        "download"?: string;
        /**
          * Passed to anchor
         */
        "href"?: string;
        /**
          * Passed to anchor
         */
        "rel"?: string;
        /**
          * Passed to anchor
         */
        "target"?: string;
        /**
          * Underlines the text
          * @default true
         */
        "underline"?: boolean;
    }
    interface JeList {
    }
    interface JeLoading {
    }
    interface JeMidi {
    }
    interface JeNote {
        "invalid"?: boolean;
    }
    interface JeOption {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean;
        "value"?: any;
    }
    interface JeOverlay {
        /**
          * Backdrop will close the modal on click when enabled
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * Optionally execute a promise after closing completes
         */
        "destroy"?: () => void | Promise<void>;
        /**
          * Optionally execute a promise before presentation begins
         */
        "init"?: () => void | Promise<void>;
        /**
          * Emits whenever the overlay has finished closing. Emits the role and optional data object passed to the hide() method.
         */
        "onDismiss"?: (event: JeOverlayCustomEvent<OverlayData>) => void;
        /**
          * Emits whenever the overlay has opened. Does not emit any data
         */
        "onPresent"?: (event: JeOverlayCustomEvent<any>) => void;
        /**
          * Opens and closes modal
          * @default false
         */
        "open"?: boolean;
        /**
          * Side of the screen where the drawer will be displayed
         */
        "side"?: 'left' | 'right' | 'bottom' | 'top';
        /**
          * Size of the overlay
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
    }
    interface JeOverlayContent {
        /**
          * @default true
         */
        "closable"?: boolean;
        "label"?: string;
    }
    interface JePage {
    }
    interface JePill {
        /**
          * @default false
         */
        "outline"?: boolean;
    }
    interface JePlaceholder {
        /**
          * Whether or not the component should have the animated "shimmer" effect
          * @default true
         */
        "animated"?: boolean;
    }
    interface JePopover {
        /**
          * Renders an arrow pointing to the trigger
          * @default true
         */
        "arrow"?: boolean;
        /**
          * The padding between the arrow and the edges of the popover. Useful if you change the border-radius of the popover
          * @default 6
         */
        "arrowPadding"?: number;
        /**
          * Backdrop will dismiss the popover on click when enabled
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * Execute a callback after the popover has dismissed
         */
        "destroy"?: () => Promise<void> | void;
        /**
          * Popover will automatically dismiss itself when something is clicked in the popover when enabled
          * @default false
         */
        "dismissOnClick"?: boolean;
        /**
          * Execute a callback before the popover starts presenting
         */
        "init"?: () => Promise<void> | void;
        /**
          * If the popover should match the width of the trigger element
          * @default false
         */
        "matchWidth"?: boolean;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY"?: number;
        /**
          * Emits when the popover is closed
         */
        "onDismiss"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover is opened
         */
        "onPresent"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits when the popover has completed it's initial render
         */
        "onReady"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits before the popover starts dismissing
         */
        "onWillDismiss"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Emits before the popover starts opening
         */
        "onWillPresent"?: (event: JePopoverCustomEvent<any>) => void;
        /**
          * Opens/closes the popover
          * @default false
         */
        "open"?: boolean;
        /**
          * Where the popover should be placed
         */
        "placement"?: Placement;
        /**
          * If the popover should position itself using the mouse event or the triggerElement.
          * @default 'element'
         */
        "positionStrategy"?: 'click' | 'element';
        /**
          * @click Popover will show on left click or tap on mobile.
          * @context-menu Popover will show on right click or press on mobile.
          * @hover Popover will show on hover or tap on mobile.
          * @default 'click'
         */
        "triggerAction"?: 'click' | 'context-menu' | 'hover';
    }
    interface JeRadio {
        /**
          * If the option is currently selected
         */
        "selected"?: boolean;
        /**
          * The value of this option and the radio group will compare against
         */
        "value"?: any;
    }
    interface JeRadioButton {
        /**
          * Changes the styling of the card to indicate it is selected
          * @default false
         */
        "selected"?: boolean;
        /**
          * The value for this option that bw-card-group will compare against
         */
        "value"?: string;
    }
    interface JeRadioGroup {
        /**
          * Disables the controls
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Label that shows above the control
         */
        "label"?: string;
        /**
          * Additional info that shows below the control
         */
        "note"?: string;
        /**
          * Emits the selected value whenever it changes
         */
        "onValueChange"?: (event: JeRadioGroupCustomEvent<any>) => void;
        /**
          * Value the form will reset to. Defaults to initial value if not specified
         */
        "originalValue"?: any;
        /**
          * Requires a value before the form can be submitted
         */
        "required"?: boolean;
        /**
          * The currently selected value
         */
        "value"?: any;
    }
    interface JeRange {
    }
    interface JeReorderItem {
    }
    interface JeReorderList {
    }
    interface JeRichText {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default '500px'
         */
        "maxHeight"?: string;
        /**
          * @default '200px'
         */
        "minHeight"?: string;
        "onEditorBlur"?: (event: JeRichTextCustomEvent<FocusEvent>) => void;
        "onEditorChange"?: (event: JeRichTextCustomEvent<EditorChangeEvent>) => void;
        "onEditorFocus"?: (event: JeRichTextCustomEvent<FocusEvent>) => void;
        /**
          * @default 'Start typing...'
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly"?: boolean;
        /**
          * @default true
         */
        "showWordCount"?: boolean;
        /**
          * @default ''
         */
        "value"?: string;
    }
    interface JeSelect {
        /**
          * @default false
         */
        "disabled"?: boolean;
        "label"?: string;
        /**
          * @default false
         */
        "multiple"?: boolean;
        "note"?: string;
        "onValueChange"?: (event: JeSelectCustomEvent<any>) => void;
        "options"?: { value: any, label: string }[];
        "originalValue"?: any;
        "placeholder"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'md' | 'lg' | 'sm';
        "value"?: any;
    }
    interface JeSplitPanel {
    }
    interface JeSplitView {
    }
    interface JeStack {
    }
    interface JeSynth {
    }
    interface JeTab {
        /**
          * @default false
         */
        "active"?: boolean;
        "value"?: string;
    }
    interface JeTabs {
        /**
          * @default 'segment'
         */
        "mode"?: 'mobile' | 'pill' | 'segment';
        "onValueChange"?: (event: JeTabsCustomEvent<string | undefined>) => void;
        "value"?: string;
    }
    interface JeTextfield {
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoCapitalize"?: string;
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoComplete"?: string;
        /**
          * Passed to native input
          * @default 'off'
         */
        "autoCorrect"?: 'off' | 'on';
        /**
          * Passed to native input
         */
        "autoFocus"?: boolean;
        /**
          * Optional debounce of the didInput event
          * @default 0
         */
        "debounce"?: number;
        /**
          * Renders input as disabled and prevents changes
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Shows an error icon in the end slot when true. If a string is passed in, it will render the icon as a tooltip. Has no effect on form validation
         */
        "error"?: any;
        /**
          * Formatters functions that are applied as the user types
         */
        "format"?: FormatterFn;
        /**
          * Passed to native input
         */
        "inputMode"?: string;
        /**
          * Text above the control
         */
        "label"?: string;
        /**
          * Passed to native input
         */
        "max"?: any;
        /**
          * Passed to native input
         */
        "maxlength"?: number;
        /**
          * Passed to native input
         */
        "min"?: any;
        /**
          * Passed to native input
         */
        "minlength"?: number;
        /**
          * Whether the control is a multiline textarea
          * @default false
         */
        "multiline"?: boolean;
        /**
          * Informational message directly below the control
         */
        "note"?: string;
        /**
          * Emits as the user types
         */
        "onValueChange"?: (event: JeTextfieldCustomEvent<any>) => void;
        /**
          * The default value the control will reset to in a form. If not set, will default to the inital value of the "value" property.
         */
        "originalValue"?: string;
        /**
          * Passed to native input
         */
        "pattern"?: string;
        /**
          * Shows a loading indicator in the end slot when true
          * @default false
         */
        "pending"?: boolean;
        /**
          * Input placeholder text
         */
        "placeholder"?: string;
        /**
          * Renders input as read only and prevents changes
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Marks as required in form and adds asterisk to the end of the label
          * @default false
         */
        "required"?: boolean;
        /**
          * Container size
          * @default 'md'
         */
        "size"?: 'md' | 'lg' | 'sm';
        /**
          * Passed to native input
          * @default false
         */
        "spellcheck"?: boolean;
        /**
          * Passed to native input
         */
        "step"?: string;
        /**
          * Shows a success icon in the end slot when true. Has no effect on form validation
          * @default false
         */
        "success"?: boolean;
        /**
          * Whether to suppress the default behavior of the input event
          * @default false
         */
        "suppressDefaultBehavior"?: boolean;
        /**
          * Transforms the value before it is passed to the input (from) and after the input emits a new value (to).  There are built-in transformers for 'number', 'date', and 'datetime'.
         */
        "transform"?: InputTransformer | 'number' | 'date' | 'datetime';
        /**
          * Passed to native input
          * @default 'text'
         */
        "type"?: string;
        /**
          * Validator functions for form participation
         */
        "validators"?: ValidationFn[];
        /**
          * Current value of the input
         */
        "value"?: any;
        /**
          * Passed to native textarea
         */
        "wrap"?: string;
    }
    interface JeToggle {
        /**
          * If the label should be placed at the start or end of the toggle
          * @default 'end'
         */
        "labelPlacement"?: 'start' | 'end';
        /**
          * Emits the new value whenever toggle is clicked
         */
        "onValueChange"?: (event: JeToggleCustomEvent<boolean>) => void;
        /**
          * Original value form will reset to
         */
        "originalValue"?: boolean;
        /**
          * Whether or not the toggle is active
          * @default false
         */
        "value"?: boolean;
    }
    interface JeToolbar {
    }
    interface JeTooltip {
        /**
          * The content of the tooltip
         */
        "content"?: string;
        /**
          * Horizontal offset used when auto positioning the popover content
          * @default 0
         */
        "offsetX"?: number;
        /**
          * Vertical offset used when auto positioning the popover content
          * @default 10
         */
        "offsetY"?: number;
    }
    interface JeTree {
        /**
          * @default false
         */
        "indentation"?: boolean;
        "onValueChange"?: (event: JeTreeCustomEvent<string | string[]>) => void;
        /**
          * @default 'leaf'
         */
        "selection"?: 'single' | 'multiple' | 'leaf';
        "value"?: string | string[];
    }
    interface JeWizard {
        "onFinish"?: (event: JeWizardCustomEvent<void>) => void;
        "onStepChange"?: (event: JeWizardCustomEvent<number>) => void;
        /**
          * @default []
         */
        "steps"?: { label: string, optional?: boolean }[];
    }
    interface IntrinsicElements {
        "je-accordion": JeAccordion;
        "je-alert": JeAlert;
        "je-branch": JeBranch;
        "je-breadcrumb": JeBreadcrumb;
        "je-breadcrumbs": JeBreadcrumbs;
        "je-button": JeButton;
        "je-button-group": JeButtonGroup;
        "je-calendar": JeCalendar;
        "je-card": JeCard;
        "je-checkbox": JeCheckbox;
        "je-color": JeColor;
        "je-comp": JeComp;
        "je-control": JeControl;
        "je-datepicker": JeDatepicker;
        "je-daw": JeDaw;
        "je-details": JeDetails;
        "je-discard-form": JeDiscardForm;
        "je-divider": JeDivider;
        "je-dropzone": JeDropzone;
        "je-eq": JeEq;
        "je-form": JeForm;
        "je-grid": JeGrid;
        "je-icon": JeIcon;
        "je-item": JeItem;
        "je-knob": JeKnob;
        "je-label": JeLabel;
        "je-link": JeLink;
        "je-list": JeList;
        "je-loading": JeLoading;
        "je-midi": JeMidi;
        "je-note": JeNote;
        "je-option": JeOption;
        "je-overlay": JeOverlay;
        "je-overlay-content": JeOverlayContent;
        "je-page": JePage;
        "je-pill": JePill;
        "je-placeholder": JePlaceholder;
        "je-popover": JePopover;
        "je-radio": JeRadio;
        "je-radio-button": JeRadioButton;
        "je-radio-group": JeRadioGroup;
        "je-range": JeRange;
        "je-reorder-item": JeReorderItem;
        "je-reorder-list": JeReorderList;
        "je-rich-text": JeRichText;
        "je-select": JeSelect;
        "je-split-panel": JeSplitPanel;
        "je-split-view": JeSplitView;
        "je-stack": JeStack;
        "je-synth": JeSynth;
        "je-tab": JeTab;
        "je-tabs": JeTabs;
        "je-textfield": JeTextfield;
        "je-toggle": JeToggle;
        "je-toolbar": JeToolbar;
        "je-tooltip": JeTooltip;
        "je-tree": JeTree;
        "je-wizard": JeWizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Accordions are wrappers for [JeDetails](../je-details). When an inner detail is opened, the others are automatically closed.
             * The implementation follows the [aria implementation of an accordion](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
             */
            "je-accordion": LocalJSX.JeAccordion & JSXBase.HTMLAttributes<HTMLJeAccordionElement>;
            "je-alert": LocalJSX.JeAlert & JSXBase.HTMLAttributes<HTMLJeAlertElement>;
            "je-branch": LocalJSX.JeBranch & JSXBase.HTMLAttributes<HTMLJeBranchElement>;
            "je-breadcrumb": LocalJSX.JeBreadcrumb & JSXBase.HTMLAttributes<HTMLJeBreadcrumbElement>;
            "je-breadcrumbs": LocalJSX.JeBreadcrumbs & JSXBase.HTMLAttributes<HTMLJeBreadcrumbsElement>;
            "je-button": LocalJSX.JeButton & JSXBase.HTMLAttributes<HTMLJeButtonElement>;
            "je-button-group": LocalJSX.JeButtonGroup & JSXBase.HTMLAttributes<HTMLJeButtonGroupElement>;
            "je-calendar": LocalJSX.JeCalendar & JSXBase.HTMLAttributes<HTMLJeCalendarElement>;
            "je-card": LocalJSX.JeCard & JSXBase.HTMLAttributes<HTMLJeCardElement>;
            "je-checkbox": LocalJSX.JeCheckbox & JSXBase.HTMLAttributes<HTMLJeCheckboxElement>;
            "je-color": LocalJSX.JeColor & JSXBase.HTMLAttributes<HTMLJeColorElement>;
            "je-comp": LocalJSX.JeComp & JSXBase.HTMLAttributes<HTMLJeCompElement>;
            "je-control": LocalJSX.JeControl & JSXBase.HTMLAttributes<HTMLJeControlElement>;
            "je-datepicker": LocalJSX.JeDatepicker & JSXBase.HTMLAttributes<HTMLJeDatepickerElement>;
            "je-daw": LocalJSX.JeDaw & JSXBase.HTMLAttributes<HTMLJeDawElement>;
            "je-details": LocalJSX.JeDetails & JSXBase.HTMLAttributes<HTMLJeDetailsElement>;
            "je-discard-form": LocalJSX.JeDiscardForm & JSXBase.HTMLAttributes<HTMLJeDiscardFormElement>;
            "je-divider": LocalJSX.JeDivider & JSXBase.HTMLAttributes<HTMLJeDividerElement>;
            "je-dropzone": LocalJSX.JeDropzone & JSXBase.HTMLAttributes<HTMLJeDropzoneElement>;
            "je-eq": LocalJSX.JeEq & JSXBase.HTMLAttributes<HTMLJeEqElement>;
            "je-form": LocalJSX.JeForm & JSXBase.HTMLAttributes<HTMLJeFormElement>;
            "je-grid": LocalJSX.JeGrid & JSXBase.HTMLAttributes<HTMLJeGridElement>;
            "je-icon": LocalJSX.JeIcon & JSXBase.HTMLAttributes<HTMLJeIconElement>;
            "je-item": LocalJSX.JeItem & JSXBase.HTMLAttributes<HTMLJeItemElement>;
            "je-knob": LocalJSX.JeKnob & JSXBase.HTMLAttributes<HTMLJeKnobElement>;
            "je-label": LocalJSX.JeLabel & JSXBase.HTMLAttributes<HTMLJeLabelElement>;
            "je-link": LocalJSX.JeLink & JSXBase.HTMLAttributes<HTMLJeLinkElement>;
            "je-list": LocalJSX.JeList & JSXBase.HTMLAttributes<HTMLJeListElement>;
            "je-loading": LocalJSX.JeLoading & JSXBase.HTMLAttributes<HTMLJeLoadingElement>;
            "je-midi": LocalJSX.JeMidi & JSXBase.HTMLAttributes<HTMLJeMidiElement>;
            "je-note": LocalJSX.JeNote & JSXBase.HTMLAttributes<HTMLJeNoteElement>;
            "je-option": LocalJSX.JeOption & JSXBase.HTMLAttributes<HTMLJeOptionElement>;
            "je-overlay": LocalJSX.JeOverlay & JSXBase.HTMLAttributes<HTMLJeOverlayElement>;
            "je-overlay-content": LocalJSX.JeOverlayContent & JSXBase.HTMLAttributes<HTMLJeOverlayContentElement>;
            "je-page": LocalJSX.JePage & JSXBase.HTMLAttributes<HTMLJePageElement>;
            "je-pill": LocalJSX.JePill & JSXBase.HTMLAttributes<HTMLJePillElement>;
            "je-placeholder": LocalJSX.JePlaceholder & JSXBase.HTMLAttributes<HTMLJePlaceholderElement>;
            "je-popover": LocalJSX.JePopover & JSXBase.HTMLAttributes<HTMLJePopoverElement>;
            "je-radio": LocalJSX.JeRadio & JSXBase.HTMLAttributes<HTMLJeRadioElement>;
            "je-radio-button": LocalJSX.JeRadioButton & JSXBase.HTMLAttributes<HTMLJeRadioButtonElement>;
            "je-radio-group": LocalJSX.JeRadioGroup & JSXBase.HTMLAttributes<HTMLJeRadioGroupElement>;
            "je-range": LocalJSX.JeRange & JSXBase.HTMLAttributes<HTMLJeRangeElement>;
            "je-reorder-item": LocalJSX.JeReorderItem & JSXBase.HTMLAttributes<HTMLJeReorderItemElement>;
            "je-reorder-list": LocalJSX.JeReorderList & JSXBase.HTMLAttributes<HTMLJeReorderListElement>;
            "je-rich-text": LocalJSX.JeRichText & JSXBase.HTMLAttributes<HTMLJeRichTextElement>;
            "je-select": LocalJSX.JeSelect & JSXBase.HTMLAttributes<HTMLJeSelectElement>;
            "je-split-panel": LocalJSX.JeSplitPanel & JSXBase.HTMLAttributes<HTMLJeSplitPanelElement>;
            "je-split-view": LocalJSX.JeSplitView & JSXBase.HTMLAttributes<HTMLJeSplitViewElement>;
            "je-stack": LocalJSX.JeStack & JSXBase.HTMLAttributes<HTMLJeStackElement>;
            "je-synth": LocalJSX.JeSynth & JSXBase.HTMLAttributes<HTMLJeSynthElement>;
            "je-tab": LocalJSX.JeTab & JSXBase.HTMLAttributes<HTMLJeTabElement>;
            "je-tabs": LocalJSX.JeTabs & JSXBase.HTMLAttributes<HTMLJeTabsElement>;
            "je-textfield": LocalJSX.JeTextfield & JSXBase.HTMLAttributes<HTMLJeTextfieldElement>;
            "je-toggle": LocalJSX.JeToggle & JSXBase.HTMLAttributes<HTMLJeToggleElement>;
            "je-toolbar": LocalJSX.JeToolbar & JSXBase.HTMLAttributes<HTMLJeToolbarElement>;
            "je-tooltip": LocalJSX.JeTooltip & JSXBase.HTMLAttributes<HTMLJeTooltipElement>;
            "je-tree": LocalJSX.JeTree & JSXBase.HTMLAttributes<HTMLJeTreeElement>;
            "je-wizard": LocalJSX.JeWizard & JSXBase.HTMLAttributes<HTMLJeWizardElement>;
        }
    }
}
